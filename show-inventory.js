/**
 * Ğ¡ĞºÑ€Ğ¸Ğ¿Ñ‚ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€Ğ° Ğ¸Ğ½Ğ²ĞµĞ½Ñ‚Ğ°Ñ€Ñ Ğ¿ĞµÑ€ÑĞ¾Ğ½Ğ°Ğ¶ĞµĞ¹
 * ĞŸĞ¾Ğ»ĞµĞ·ĞµĞ½ Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ»Ğ°Ğ´ĞºĞ¸
 */

require('dotenv').config();
const mongoose = require('mongoose');
const Character = require('./models/Character');

async function showInventory() {
  try {
    // ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡Ğ°ĞµĞ¼ÑÑ Ğº MongoDB
    await mongoose.connect(process.env.MONGODB_URI);
    console.log('âœ… ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¾ Ğº MongoDB');

    // ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ²ÑĞµ Ğ¿ĞµÑ€ÑĞ¾Ğ½Ğ°Ğ¶Ğ¸
    const characters = await Character.find({});

    console.log(`\nğŸ“Š Ğ’ÑĞµĞ³Ğ¾ Ğ¿ĞµÑ€ÑĞ¾Ğ½Ğ°Ğ¶ĞµĞ¹: ${characters.length}\n`);

    for (const character of characters) {
      console.log(`â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`);
      console.log(`ğŸ® ĞŸĞµÑ€ÑĞ¾Ğ½Ğ°Ğ¶: ${character.characterClass}`);
      console.log(`   User ID: ${character.userId}`);
      console.log(`   Level: ${character.level}`);
      console.log(`   Gold: ${character.gold}`);
      console.log(`   ĞŸÑ€ĞµĞ´Ğ¼ĞµÑ‚Ğ¾Ğ² Ğ² Ğ¸Ğ½Ğ²ĞµĞ½Ñ‚Ğ°Ñ€Ğµ: ${character.inventory?.length || 0}`);

      if (character.inventory && character.inventory.length > 0) {
        console.log(`\n   ğŸ“¦ Ğ˜Ğ½Ğ²ĞµĞ½Ñ‚Ğ°Ñ€ÑŒ:`);
        character.inventory.forEach((item, index) => {
          console.log(`      [${index}] ${item.itemName || 'Unknown'} x${item.quantity || 1}`);
          console.log(`          ID: ${item.itemId || 'EMPTY'}`);
          console.log(`          Slot: ${item.slotIndex ?? 'UNDEFINED'}`);
          console.log(`          Timestamp: ${item.timestamp ? new Date(item.timestamp).toISOString() : 'N/A'}`);
        });
      }
      console.log('');
    }

    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

  } catch (error) {
    console.error('âŒ ĞÑˆĞ¸Ğ±ĞºĞ°:', error);
  } finally {
    await mongoose.disconnect();
    console.log('ğŸ‘‹ ĞÑ‚ĞºĞ»ÑÑ‡ĞµĞ½Ğ¾ Ğ¾Ñ‚ MongoDB');
  }
}

showInventory();
