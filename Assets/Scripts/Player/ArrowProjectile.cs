using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// Arrow Projectile - —É–ª—É—á—à–µ–Ω–Ω—ã–π —Å–Ω–∞—Ä—è–¥ —Å—Ç—Ä–µ–ª—ã —Å –∞–≤—Ç–æ–Ω–∞–≤–µ–¥–µ–Ω–∏–µ–º
/// –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –æ–±—ã—á–Ω–æ–π –∞—Ç–∞–∫–∏ –ª—É—á–Ω–∏–∫–∞
/// </summary>
public class ArrowProjectile : MonoBehaviour
{
    [Header("Movement Settings")]
    [SerializeField] private float baseSpeed = 25f; // –ë–∞–∑–æ–≤–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å
    [SerializeField] private float homingSpeed = 10f; // –°–∫–æ—Ä–æ—Å—Ç—å –ø–æ–≤–æ—Ä–æ—Ç–∞ –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏
    [SerializeField] private float lifetime = 5f; // –í—Ä–µ–º—è –∂–∏–∑–Ω–∏
    [SerializeField] private float accelerationRate = 1.2f; // –£—Å–∫–æ—Ä–µ–Ω–∏–µ —Å–æ –≤—Ä–µ–º–µ–Ω–µ–º

    [Header("Homing Settings")]
    [SerializeField] private bool enableHoming = true; // –ê–≤—Ç–æ–Ω–∞–≤–µ–¥–µ–Ω–∏–µ
    [SerializeField] private float homingStartDelay = 0.05f; // –ó–∞–¥–µ—Ä–∂–∫–∞ –ø–µ—Ä–µ–¥ –Ω–∞—á–∞–ª–æ–º –Ω–∞–≤–µ–¥–µ–Ω–∏—è
    [SerializeField] private float homingRadius = 35f; // –†–∞–¥–∏—É—Å –ø–æ–∏—Å–∫–∞ —Ü–µ–ª–∏
    [SerializeField] private float targetAcquisitionAngle = 90f; // –£–≥–æ–ª –ø–æ–∏—Å–∫–∞ —Ü–µ–ª–∏

    [Header("Visual Effects")]
    [SerializeField] private ParticleSystem hitEffect; // –≠—Ñ—Ñ–µ–∫—Ç –≤–∑—Ä—ã–≤–∞
    [SerializeField] private Light projectileLight; // –°–≤–µ—á–µ–Ω–∏–µ
    [SerializeField] private TrailRenderer trail; // –°–ª–µ–¥

    [Header("Rotation")]
    [SerializeField] private float rotationSpeed = 0f; // –í—Ä–∞—â–µ–Ω–∏–µ –≤–∏–∑—É–∞–ª–∞
    [SerializeField] private Transform visualTransform; // –¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º –¥–ª—è –≤—Ä–∞—â–µ–Ω–∏—è

    [Header("Audio")]
    [SerializeField] private AudioClip launchSound;
    [SerializeField] private AudioClip hitSound;

    // Runtime variables
    private Transform target;
    private float damage;
    private bool isCritical = false;
    private Vector3 direction;
    private float spawnTime;
    private GameObject owner;
    private List<EffectConfig> effects; // –≠—Ñ—Ñ–µ–∫—Ç—ã —Å–∫–∏–ª–ª–∞
    private CharacterStats casterStats; // –°—Ç–∞—Ç—ã –∫–∞—Å—Ç–µ—Ä–∞ –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–æ–≤
    private float currentSpeed;
    private bool hasHit = false;
    private AudioSource audioSource;

    /// <summary>
    /// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–Ω–∞—Ä—è–¥–∞
    /// </summary>
    /// <param name="isVisualOnly">–ï—Å–ª–∏ true, —Å–Ω–∞—Ä—è–¥ —á–∏—Å—Ç–æ –≤–∏–∑—É–∞–ª—å–Ω—ã–π (–±–µ–∑ –∫–æ–ª–ª–∏–∑–∏–∏, –∞–≤—Ç–æ–Ω–∞–≤–µ–¥–µ–Ω–∏—è, —É—Ä–æ–Ω–∞)</param>
    public void Initialize(Transform targetTransform, float projectileDamage, Vector3 initialDirection, GameObject projectileOwner = null, List<EffectConfig> skillEffects = null, bool isVisualOnly = false, bool isCrit = false)
    {
        target = targetTransform;
        damage = projectileDamage;
        isCritical = isCrit;
        direction = initialDirection.normalized;
        spawnTime = Time.time;
        owner = projectileOwner;
        effects = skillEffects;
        currentSpeed = baseSpeed;

        // –ï—Å–ª–∏ —ç—Ç–æ –≤–∏–∑—É–∞–ª—å–Ω—ã–π —Å–Ω–∞—Ä—è–¥ - –æ—Ç–∫–ª—é—á–∞–µ–º –∞–≤—Ç–æ–Ω–∞–≤–µ–¥–µ–Ω–∏–µ –∏ –∫–æ–ª–ª–∏–∑–∏—é
        if (isVisualOnly)
        {
            enableHoming = false;

            // –û—Ç–∫–ª—é—á–∞–µ–º –∫–æ–ª–ª–∞–π–¥–µ—Ä –¥–ª—è –≤–∏–∑—É–∞–ª—å–Ω—ã—Ö —Å–Ω–∞—Ä—è–¥–æ–≤
            Collider col = GetComponent<Collider>();
            if (col != null)
            {
                col.enabled = false;
            }

            // –£–º–µ–Ω—å—à–∞–µ–º lifetime –¥–ª—è –≤–∏–∑—É–∞–ª—å–Ω—ã—Ö —Å–Ω–∞—Ä—è–¥–æ–≤ (1.5 —Å–µ–∫—É–Ω–¥—ã –≤–º–µ—Å—Ç–æ 5)
            // –≠—Ç–æ –ø—Ä–∏–º–µ—Ä–Ω–æ –≤—Ä–µ–º—è –ø–æ–ª–µ—Ç–∞ –Ω–∞ 20-25 –º–µ—Ç—Ä–æ–≤ –ø—Ä–∏ —Å–∫–æ—Ä–æ—Å—Ç–∏ 15 –º/—Å
            lifetime = 1.5f;

            Debug.Log($"[ArrowProjectile] üëÅÔ∏è –í–∏–∑—É–∞–ª—å–Ω—ã–π —Å–Ω–∞—Ä—è–¥ —Å–æ–∑–¥–∞–Ω (–±–µ–∑ –∫–æ–ª–ª–∏–∑–∏–∏, –∞–≤—Ç–æ–Ω–∞–≤–µ–¥–µ–Ω–∏—è, lifetime: {lifetime}s)");
        }

        // –ü–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º —Å–Ω–∞—Ä—è–¥ –ø–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—é –ø–æ–ª–µ—Ç–∞
        if (direction != Vector3.zero)
        {
            transform.rotation = Quaternion.LookRotation(direction);
        }

        // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –∞—É–¥–∏–æ
        audioSource = GetComponent<AudioSource>();
        if (audioSource != null && launchSound != null)
        {
            audioSource.PlayOneShot(launchSound);
        }

        // –ê–≤—Ç–æ–ø–æ–∏—Å–∫ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ –µ—Å–ª–∏ –Ω–µ –Ω–∞–∑–Ω–∞—á–µ–Ω—ã
        AutoFindComponents();

        Debug.Log($"[ArrowProjectile] ‚ú® –°–æ–∑–¥–∞–Ω! Target: {target?.name ?? "None"}, Damage: {damage}, Homing: {enableHoming}, Visual: {isVisualOnly}");
    }

    /// <summary>
    /// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–Ω–∞—Ä—è–¥–∞ —Å –Ω–æ–≤–æ–π —Å–∏—Å—Ç–µ–º–æ–π —ç—Ñ—Ñ–µ–∫—Ç–æ–≤ (EffectConfig)
    /// </summary>
    public void InitializeWithEffects(Transform targetTransform, float projectileDamage, Vector3 initialDirection, GameObject projectileOwner, List<EffectConfig> skillEffectConfigs, CharacterStats stats, bool isVisualOnly = false, bool isCrit = false)
    {
        // –í—ã–∑—ã–≤–∞–µ–º –±–∞–∑–æ–≤—É—é –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é
        Initialize(targetTransform, projectileDamage, initialDirection, projectileOwner, null, isVisualOnly, isCrit);

        // –°–æ—Ö—Ä–∞–Ω—è–µ–º —ç—Ñ—Ñ–µ–∫—Ç—ã –Ω–æ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã
        effects = skillEffectConfigs;
        casterStats = stats;

        if (effects != null && effects.Count > 0)
        {
            Debug.Log("[ArrowProjectile] Initialized with " + effects.Count + " effects (new system)");
        }
    }

    /// <summary>
    /// –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —ç—Ñ—Ñ–µ–∫—Ç –ø–æ–ø–∞–¥–∞–Ω–∏—è –∏–∑ BasicAttackConfig
    /// </summary>
    public void SetHitEffect(ParticleSystem effect)
    {
        hitEffect = effect;
        Debug.Log($"[ArrowProjectile] üé® Hit effect —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {effect?.name ?? "None"}");
    }

    /// <summary>
    /// –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
    /// </summary>
    private void AutoFindComponents()
    {
        if (projectileLight == null)
            projectileLight = GetComponentInChildren<Light>();

        if (trail == null)
            trail = GetComponentInChildren<TrailRenderer>();

        if (visualTransform == null && transform.childCount > 0)
            visualTransform = transform.GetChild(0);

        {
            // –ò—â–µ–º —ç—Ñ—Ñ–µ–∫—Ç –≤–µ—Ç—Ä–∞ –≤ –¥–æ—á–µ—Ä–Ω–∏—Ö –æ–±—ä–µ–∫—Ç–∞—Ö
            ParticleSystem[] particles = GetComponentsInChildren<ParticleSystem>();
            foreach (var ps in particles)
            {
                if (ps.gameObject != gameObject && ps.name.Contains("Wind"))
                {
                    break;
                }
            }
        }
    }

    void Update()
    {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏
        if (Time.time - spawnTime > lifetime)
        {
            DestroySelf();
            return;
        }

        // –î–≤–∏–∂–µ–Ω–∏–µ —Å–Ω–∞—Ä—è–¥–∞
        MoveProjectile();

        // –í—Ä–∞—â–µ–Ω–∏–µ –≤–∏–∑—É–∞–ª—å–Ω–æ–π —á–∞—Å—Ç–∏
        RotateVisual();

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è —Ü–µ–ª–∏
        CheckTargetHit();
    }

    /// <summary>
    /// –î–≤–∏–∂–µ–Ω–∏–µ —Å–Ω–∞—Ä—è–¥–∞ —Å –∞–≤—Ç–æ–Ω–∞–≤–µ–¥–µ–Ω–∏–µ–º
    /// </summary>
    private void MoveProjectile()
    {
        // –£—Å–∫–æ—Ä–µ–Ω–∏–µ —Å–æ –≤—Ä–µ–º–µ–Ω–µ–º (–¥–ª—è –±–æ–ª–µ–µ –¥–∏–Ω–∞–º–∏—á–Ω–æ–≥–æ –ø–æ–ª–µ—Ç–∞)
        float timeSinceSpawn = Time.time - spawnTime;
        currentSpeed = baseSpeed + (timeSinceSpawn * accelerationRate);

        // –ê–≤—Ç–æ–Ω–∞–≤–µ–¥–µ–Ω–∏–µ
        if (enableHoming && timeSinceSpawn > homingStartDelay)
        {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ—Å—Ç—å –ª–∏ —Ü–µ–ª—å
            if (target == null || !IsTargetValid(target))
            {
                // –ü—ã—Ç–∞–µ–º—Å—è –Ω–∞–π—Ç–∏ –Ω–æ–≤—É—é —Ü–µ–ª—å
                target = FindNearestTarget();
            }

            if (target != null)
            {
                // –í—ã—á–∏—Å–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫ —Ü–µ–ª–∏
                Vector3 targetDirection = (target.position - transform.position).normalized;

                // –ü–ª–∞–≤–Ω–æ –ø–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –∫ —Ü–µ–ª–∏ (–∫–∞–∫ —É–ø—Ä–∞–≤–ª—è–µ–º–∞—è —Ä–∞–∫–µ—Ç–∞)
                direction = Vector3.RotateTowards(
                    direction,
                    targetDirection,
                    homingSpeed * Time.deltaTime,
                    0f
                ).normalized;

                // –û–±–Ω–æ–≤–ª—è–µ–º —Ä–æ—Ç–∞—Ü–∏—é —Å–Ω–∞—Ä—è–¥–∞
                transform.rotation = Quaternion.LookRotation(direction);
            }
        }

        // –î–≤–∏–≥–∞–µ–º —Å–Ω–∞—Ä—è–¥
        transform.position += direction * currentSpeed * Time.deltaTime;
    }

    /// <summary>
    /// –í—Ä–∞—â–µ–Ω–∏–µ –≤–∏–∑—É–∞–ª—å–Ω–æ–π —á–∞—Å—Ç–∏ —Å–Ω–∞—Ä—è–¥–∞
    /// </summary>
    private void RotateVisual()
    {
        if (visualTransform != null && rotationSpeed > 0)
        {
            // –í—Ä–∞—â–∞–µ–º –≤–æ–∫—Ä—É–≥ –æ—Å–∏ Z (–∫–∞–∫ –ø–ª–∞–Ω–µ—Ç–∞)
            visualTransform.Rotate(Vector3.forward * rotationSpeed * Time.deltaTime, Space.Self);

            // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–µ –º–µ–¥–ª–µ–Ω–Ω–æ–µ –≤—Ä–∞—â–µ–Ω–∏–µ –≤–æ–∫—Ä—É–≥ Y (–±–æ–ª–µ–µ –∏–Ω—Ç–µ—Ä–µ—Å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç)
            visualTransform.Rotate(Vector3.up * (rotationSpeed * 0.3f) * Time.deltaTime, Space.Self);
        }
    }

    /// <summary>
    /// –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è –≤ —Ü–µ–ª—å
    /// </summary>
    private void CheckTargetHit()
    {
        if (hasHit || target == null) return;

        float distanceToTarget = Vector3.Distance(transform.position, target.position);

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–µ —Ü–µ–ª–∏ (—É–≤–µ–ª–∏—á–µ–Ω–Ω—ã–π —Ä–∞–¥–∏—É—Å –¥–ª—è –Ω–∞–¥–µ–∂–Ω–æ—Å—Ç–∏)
        if (distanceToTarget < 1.0f)
        {
            HitTarget();
        }
    }

    /// <summary>
    /// –ü–æ–ø–∞–¥–∞–Ω–∏–µ –≤ —Ü–µ–ª—å
    /// </summary>
    private void HitTarget()
    {
        if (hasHit) return;
        hasHit = true;

        Debug.Log($"[ArrowProjectile] üí• –ü–æ–ø–∞–¥–∞–Ω–∏–µ –≤ {target?.name}! –£—Ä–æ–Ω: {damage}");

        // –ù–∞–Ω–æ—Å–∏–º —É—Ä–æ–Ω
        if (target != null)
        {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∏–ø —Ü–µ–ª–∏
            Enemy enemy = target.GetComponent<Enemy>();
            DummyEnemy dummy = target.GetComponent<DummyEnemy>();
            NetworkPlayer networkTarget = target.GetComponent<NetworkPlayer>();

            if (enemy != null && enemy.IsAlive() && networkTarget == null)
            {
                // –û–±—ã—á–Ω—ã–π NPC –≤—Ä–∞–≥ - –Ω–∞–Ω–æ—Å–∏–º —É—Ä–æ–Ω –ª–æ–∫–∞–ª—å–Ω–æ
                enemy.TakeDamage(damage);
                Debug.Log($"[ArrowProjectile] ‚úÖ –£—Ä–æ–Ω –Ω–∞–Ω–µ—Å–µ–Ω NPC: {damage}");

                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ü–∏—Ñ—Ä—É —É—Ä–æ–Ω–∞
                if (DamageNumberManager.Instance != null)
                {
                    DamageNumberManager.Instance.ShowDamage(target.position, damage, isCritical);
                }
            }
            else if (dummy != null && dummy.IsAlive())
            {
                // DummyEnemy - —Ç–µ—Å—Ç–æ–≤—ã–π –≤—Ä–∞–≥
                dummy.TakeDamage(damage);
                Debug.Log($"[ArrowProjectile] ‚úÖ –£—Ä–æ–Ω –Ω–∞–Ω–µ—Å–µ–Ω DummyEnemy: {damage}");

                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ü–∏—Ñ—Ä—É —É—Ä–æ–Ω–∞
                if (DamageNumberManager.Instance != null)
                {
                    DamageNumberManager.Instance.ShowDamage(target.position, damage, isCritical);
                }
            }
            else if (networkTarget != null)
            {
                // –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –ò–ó–ú–ï–ù–ï–ù–ò–ï: –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É—Ä–æ–Ω —á–µ—Ä–µ–∑ NetworkCombatSync!
                Debug.Log($"[ArrowProjectile] üéØ –ü–æ–ø–∞–¥–∞–Ω–∏–µ –≤ –∏–≥—Ä–æ–∫–∞ {networkTarget.username}! –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É—Ä–æ–Ω –Ω–∞ —Å–µ—Ä–≤–µ—Ä...");

                // –ù–∞—Ö–æ–¥–∏–º –≤–ª–∞–¥–µ–ª—å—Ü–∞ —Å–Ω–∞—Ä—è–¥–∞ (—Ç–æ–≥–æ –∫—Ç–æ –µ–≥–æ –≤—ã–ø—É—Å—Ç–∏–ª)
                if (owner != null)
                {
                    NetworkCombatSync ownerSync = owner.GetComponent<NetworkCombatSync>();
                    if (ownerSync != null)
                    {
                        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É—Ä–æ–Ω –Ω–∞ —Å–µ—Ä–≤–µ—Ä (—Å–µ—Ä–≤–µ—Ä —Ä–∞—Å—Å—á–∏—Ç–∞–µ—Ç —É—Ä–æ–Ω —Å —É—á–µ—Ç–æ–º SPECIAL stats)
                        ownerSync.SendAttack(target.gameObject, damage, "skill");
                        Debug.Log($"[ArrowProjectile] ‚úÖ –£—Ä–æ–Ω –æ—Ç —Å–∫–∏–ª–ª–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ —Å–µ—Ä–≤–µ—Ä —á–µ—Ä–µ–∑ NetworkCombatSync!");
                    }
                    else
                    {
                        Debug.LogWarning($"[ArrowProjectile] ‚ö†Ô∏è NetworkCombatSync –Ω–µ –Ω–∞–π–¥–µ–Ω —É –≤–ª–∞–¥–µ–ª—å—Ü–∞ —Å–Ω–∞—Ä—è–¥–∞!");
                    }
                }
                else
                {
                    Debug.LogWarning($"[ArrowProjectile] ‚ö†Ô∏è –í–ª–∞–¥–µ–ª–µ—Ü —Å–Ω–∞—Ä—è–¥–∞ (owner) –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!");
                }
            }

            // –ü—Ä–∏–º–µ–Ω—è–µ–º —ç—Ñ—Ñ–µ–∫—Ç—ã —Å–∫–∏–ª–ª–∞ (–µ—Å–ª–∏ –µ—Å—Ç—å)
            if (effects != null && effects.Count > 0)
            {
                SkillManager targetSkillManager = target.GetComponent<SkillManager>();
                if (targetSkillManager != null)
                {
                    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—É–±–ª–∏—á–Ω—ã–π –º–µ—Ç–æ–¥ AddEffect –∏–∑ SkillManager
                    foreach (var effect in effects)
                    {
                        targetSkillManager.AddEffect(effect, target);
                    }
                    Debug.Log($"[ArrowProjectile] ‚ú® –ü—Ä–∏–º–µ–Ω–µ–Ω–æ —ç—Ñ—Ñ–µ–∫—Ç–æ–≤: {effects.Count}");
                }
                else
                {
                    Debug.LogWarning($"[ArrowProjectile] ‚ö†Ô∏è –£ —Ü–µ–ª–∏ {target.name} –Ω–µ—Ç SkillManager –¥–ª—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è —ç—Ñ—Ñ–µ–∫—Ç–æ–≤!");
                }
            }

            // –ù–æ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞ —ç—Ñ—Ñ–µ–∫—Ç–æ–≤ (EffectConfig + EffectManager)
            if (effects != null && effects.Count > 0)
            {
                EffectManager targetEffectManager = target.GetComponent<EffectManager>();
                if (targetEffectManager != null)
                {
                    foreach (var effectConfig in effects)
                    {
                        targetEffectManager.ApplyEffect(effectConfig, casterStats);
                    }
                    Debug.Log("[ArrowProjectile] Applied " + effects.Count + " effects (new system)");
                }
                else
                {
                    Debug.LogWarning("[ArrowProjectile] Target " + target.name + " has no EffectManager!");
                }
            }
        }

        // –°–æ–∑–¥–∞–µ–º —ç—Ñ—Ñ–µ–∫—Ç –≤–∑—Ä—ã–≤–∞
        SpawnHitEffect();

        // –ó–≤—É–∫ –ø–æ–ø–∞–¥–∞–Ω–∏—è
        if (audioSource != null && hitSound != null)
        {
            AudioSource.PlayClipAtPoint(hitSound, transform.position);
        }

        // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≤–∏–∑—É–∞–ª—å–Ω–æ–≥–æ —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤–∑—Ä—ã–≤–∞ –¥–ª—è –º—É–ª—å—Ç–∏–ø–ª–µ–µ—Ä–∞
        if (SocketIOManager.Instance != null && SocketIOManager.Instance.IsConnected)
        {
            string effectName = hitEffect != null ? hitEffect.name : "CFXR3 Fire Explosion B";
            // –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤: effectType, effectPrefabName, position, rotation, targetSocketId, duration, parentTransform
            SocketIOManager.Instance.SendVisualEffect(
                "explosion",              // effectType
                effectName,               // effectPrefabName
                transform.position,       // position
                Quaternion.identity,      // rotation
                "",                       // targetSocketId (–ø—É—Å—Ç–æ –¥–ª—è –≤—Å–µ—Ö)
                0f,                       // duration
                null                      // parentTransform
            );
            Debug.Log($"[ArrowProjectile] üì° –≠—Ñ—Ñ–µ–∫—Ç –≤–∑—Ä—ã–≤–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ —Å–µ—Ä–≤–µ—Ä: {effectName}");
        }

        // –£–Ω–∏—á—Ç–æ–∂–∞–µ–º —Å–Ω–∞—Ä—è–¥
        DestroySelf();
    }

    /// <summary>
    /// –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤–∑—Ä—ã–≤–∞ –ø—Ä–∏ –ø–æ–ø–∞–¥–∞–Ω–∏–∏
    /// </summary>
    private void SpawnHitEffect()
    {
        if (hitEffect != null)
        {
            ParticleSystem explosion = Instantiate(hitEffect, transform.position, Quaternion.identity);
            Destroy(explosion.gameObject, 3f);
            Debug.Log($"[ArrowProjectile] üí• –≠—Ñ—Ñ–µ–∫—Ç –≤–∑—Ä—ã–≤–∞ —Å–æ–∑–¥–∞–Ω: {hitEffect.name}");
        }
        else
        {
            Debug.LogWarning("[ArrowProjectile] ‚ö†Ô∏è Hit effect –Ω–µ –Ω–∞–∑–Ω–∞—á–µ–Ω!");
        }
    }

    /// <summary>
    /// –ü–æ–∏—Å–∫ –±–ª–∏–∂–∞–π—à–µ–π –ø–æ–¥—Ö–æ–¥—è—â–µ–π —Ü–µ–ª–∏
    /// </summary>
    private Transform FindNearestTarget()
    {
        // –ò—â–µ–º –≤—Å–µ –∫–æ–ª–ª–∞–π–¥–µ—Ä—ã –≤—Ä–∞–≥–æ–≤ –≤ —Ä–∞–¥–∏—É—Å–µ
        Collider[] colliders = Physics.OverlapSphere(transform.position, homingRadius);
        Transform nearestTarget = null;
        float nearestDistance = float.MaxValue;

        foreach (Collider col in colliders)
        {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —ç—Ç–æ –≤—Ä–∞–≥ –∏ –Ω–µ –≤–ª–∞–¥–µ–ª–µ—Ü —Å–Ω–∞—Ä—è–¥–∞
            if (col.gameObject == owner) continue;

            Enemy enemy = col.GetComponent<Enemy>();
            NetworkPlayer networkPlayer = col.GetComponent<NetworkPlayer>();

            if (enemy != null && enemy.IsAlive())
            {
                float distance = Vector3.Distance(transform.position, col.transform.position);

                // –ü—Ä–æ–≤–µ—Ä—è–µ–º —É–≥–æ–ª (—Å–Ω–∞—Ä—è–¥ –Ω–µ –¥–æ–ª–∂–µ–Ω —Ä–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞—Ç—å—Å—è –Ω–∞ 180¬∞)
                Vector3 directionToTarget = (col.transform.position - transform.position).normalized;
                float angle = Vector3.Angle(direction, directionToTarget);

                if (angle <= targetAcquisitionAngle && distance < nearestDistance)
                {
                    nearestDistance = distance;
                    nearestTarget = col.transform;
                }
            }
            else if (networkPlayer != null)
            {
                // –°–µ—Ç–µ–≤–æ–π –∏–≥—Ä–æ–∫ —Ç–æ–∂–µ –º–æ–∂–µ—Ç –±—ã—Ç—å —Ü–µ–ª—å—é
                float distance = Vector3.Distance(transform.position, col.transform.position);
                Vector3 directionToTarget = (col.transform.position - transform.position).normalized;
                float angle = Vector3.Angle(direction, directionToTarget);

                if (angle <= targetAcquisitionAngle && distance < nearestDistance)
                {
                    nearestDistance = distance;
                    nearestTarget = col.transform;
                }
            }
        }

        if (nearestTarget != null)
        {
            Debug.Log($"[ArrowProjectile] üéØ –ù–æ–≤–∞—è —Ü–µ–ª—å –Ω–∞–π–¥–µ–Ω–∞: {nearestTarget.name} –Ω–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–∏ {nearestDistance:F1}m");
        }

        return nearestTarget;
    }

    /// <summary>
    /// –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∞–ª–∏–¥–Ω–æ—Å—Ç–∏ —Ü–µ–ª–∏
    /// </summary>
    private bool IsTargetValid(Transform target)
    {
        if (target == null) return false;

        Enemy enemy = target.GetComponent<Enemy>();
        if (enemy != null)
        {
            return enemy.IsAlive();
        }

        DummyEnemy dummy = target.GetComponent<DummyEnemy>();
        if (dummy != null)
        {
            return dummy.IsAlive();
        }

        // –°–µ—Ç–µ–≤–æ–π –∏–≥—Ä–æ–∫ –≤—Å–µ–≥–¥–∞ –≤–∞–ª–∏–¥–µ–Ω (–ø—Ä–æ–≤–µ—Ä–∫–∞ HP –Ω–∞ –µ–≥–æ —Å—Ç–æ—Ä–æ–Ω–µ)
        NetworkPlayer networkPlayer = target.GetComponent<NetworkPlayer>();
        if (networkPlayer != null)
        {
            return true;
        }

        return false;
    }

    /// <summary>
    /// –£–Ω–∏—á—Ç–æ–∂–µ–Ω–∏–µ —Å–Ω–∞—Ä—è–¥–∞
    /// </summary>
    private void DestroySelf()
    {
        Debug.Log($"[ArrowProjectile] üóëÔ∏è –£–Ω–∏—á—Ç–æ–∂–µ–Ω–∏–µ —Å–Ω–∞—Ä—è–¥–∞");
        Destroy(gameObject);
    }

    /// <summary>
    /// –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π —Å —Ç—Ä–∏–≥–≥–µ—Ä–∞–º–∏
    /// </summary>
    private void OnTriggerEnter(Collider other)
    {
        Debug.Log($"[ArrowProjectile] ‚ö° OnTriggerEnter: {other.gameObject.name}, hasHit={hasHit}");

        if (hasHit) return;

        // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –≤–ª–∞–¥–µ–ª—å—Ü–∞
        if (other.gameObject == owner)
        {
            Debug.Log($"[ArrowProjectile] ‚è≠Ô∏è –ü—Ä–æ–ø—É—Å–∫ –≤–ª–∞–¥–µ–ª—å—Ü–∞: {other.gameObject.name}");
            return;
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–ø–∞–¥–∞–Ω–∏–µ –≤ —Ü–µ–ª—å
        if (other.transform == target)
        {
            Debug.Log($"[ArrowProjectile] üéØ –ü–æ–ø–∞–¥–∞–Ω–∏–µ –≤ —Ü–µ–ª—å: {target.name}");
            HitTarget();
        }
        // –ò–ª–∏ –ø–æ–ø–∞–¥–∞–Ω–∏–µ –≤ –ª—é–±–æ–≥–æ –≤—Ä–∞–≥–∞
        else
        {
            Enemy enemy = other.GetComponent<Enemy>();
            NetworkPlayer networkPlayer = other.GetComponent<NetworkPlayer>();

            Debug.Log($"[ArrowProjectile] üîç –ü—Ä–æ–≤–µ—Ä–∫–∞: enemy={enemy != null}, networkPlayer={networkPlayer != null}");

            if ((enemy != null && enemy.IsAlive()) || networkPlayer != null)
            {
                Debug.Log($"[ArrowProjectile] ‚úÖ –ü–æ–ø–∞–¥–∞–Ω–∏–µ –≤ –≤—Ä–∞–≥–∞: {other.gameObject.name}");
                target = other.transform;
                HitTarget();
            }
            else
            {
                Debug.Log($"[ArrowProjectile] ‚ùå –ù–µ –≤—Ä–∞–≥, –ø—Ä–æ–ø—É—Å–∫: {other.gameObject.name}");
            }
        }
    }

    /// <summary>
    /// –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –≤ —Ä–µ–¥–∞–∫—Ç–æ—Ä–µ
    /// </summary>
    private void OnDrawGizmosSelected()
    {
        if (enableHoming)
        {
            // –†–∞–¥–∏—É—Å –ø–æ–∏—Å–∫–∞ —Ü–µ–ª–∏
            Gizmos.color = Color.yellow;
            Gizmos.DrawWireSphere(transform.position, homingRadius);

            // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª–µ—Ç–∞
            Gizmos.color = Color.red;
            Gizmos.DrawRay(transform.position, direction * 5f);

            // –õ–∏–Ω–∏—è –∫ —Ü–µ–ª–∏
            if (target != null)
            {
                Gizmos.color = Color.green;
                Gizmos.DrawLine(transform.position, target.position);
            }
        }
    }
}
