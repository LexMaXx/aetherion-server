using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

public class SkillExecutor : MonoBehaviour
{
    [Header("Equipped Skills")]
    public List<SkillConfig> equippedSkills = new List<SkillConfig>();

    [Header("Components")]
    private EffectManager effectManager;
    private CharacterStats stats;
    private ManaSystem manaSystem;
    private HealthSystem healthSystem;
    private Animator animator;

    [Header("Cooldowns")]
    private Dictionary<int, float> cooldownTimers = new Dictionary<int, float>();

    [Header("Minions")]
    private GameObject activeMinion; // –¢–µ–∫—É—â–∏–π –∞–∫—Ç–∏–≤–Ω—ã–π –º–∏–Ω—å–æ–Ω (—Å–∫–µ–ª–µ—Ç)

    [Header("Debug")]
    public bool enableLogs = true;

    void Awake()
    {
        effectManager = GetComponent<EffectManager>();
        if (effectManager == null)
        {
            effectManager = gameObject.AddComponent<EffectManager>();
        }

        stats = GetComponent<CharacterStats>();
        manaSystem = GetComponent<ManaSystem>();
        healthSystem = GetComponent<HealthSystem>();
        animator = GetComponent<Animator>();

        if (manaSystem == null)
        {
            Debug.LogWarning("[SkillExecutor] ‚ö†Ô∏è ManaSystem –Ω–µ –Ω–∞–π–¥–µ–Ω! –°–∫–∏–ª–ª—ã –Ω–µ –±—É–¥—É—Ç —Ç—Ä–∞—Ç–∏—Ç—å –º–∞–Ω—É.");
        }

        if (healthSystem == null)
        {
            Debug.LogWarning("[SkillExecutor] ‚ö†Ô∏è HealthSystem –Ω–µ –Ω–∞–π–¥–µ–Ω!");
        }
    }

    void Update()
    {
        List<int> keys = new List<int>(cooldownTimers.Keys);
        foreach (int slotIndex in keys)
        {
            cooldownTimers[slotIndex] -= Time.deltaTime;
            if (cooldownTimers[slotIndex] <= 0f)
            {
                cooldownTimers.Remove(slotIndex);
            }
        }
    }

    public bool UseSkill(int slotIndex, Transform target = null, Vector3? groundTarget = null)
    {
        if (slotIndex < 0 || slotIndex >= equippedSkills.Count)
        {
            Log("Invalid slot index: " + slotIndex);
            return false;
        }

        SkillConfig skill = equippedSkills[slotIndex];
        if (skill == null)
        {
            Log("No skill in slot " + slotIndex);
            return false;
        }

        if (cooldownTimers.ContainsKey(slotIndex))
        {
            Log("Skill on cooldown: " + cooldownTimers[slotIndex]);
            return false;
        }

        // –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –ü–†–û–í–ï–†–ö–ê: –î–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ª–∏ –º–∞–Ω—ã?
        if (manaSystem != null && skill.manaCost > 0)
        {
            if (!manaSystem.HasEnoughMana(skill.manaCost))
            {
                Log($"‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–∞–Ω—ã! –ù—É–∂–Ω–æ: {skill.manaCost:F0}, –ï—Å—Ç—å: {manaSystem.CurrentMana:F0}");
                return false;
            }
        }

        if (skill.requiresTarget && target == null && !groundTarget.HasValue)
        {
            Log("Skill requires target");
            return false;
        }

        // –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–ü–ï–†–ê–¶–ò–Ø: –¢—Ä–∞—Ç–∏–º –º–∞–Ω—É –ü–ï–†–ï–î –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ–º —Å–∫–∏–ª–ª–∞
        if (manaSystem != null && skill.manaCost > 0)
        {
            bool manaSpent = manaSystem.SpendMana(skill.manaCost);
            if (!manaSpent)
            {
                Log($"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ—Ç—Ä–∞—Ç–∏—Ç—å –º–∞–Ω—É!");
                return false;
            }
            Log($"‚úÖ –ü–æ—Ç—Ä–∞—á–µ–Ω–æ {skill.manaCost:F0} –º–∞–Ω—ã. –û—Å—Ç–∞–ª–æ—Å—å: {manaSystem.CurrentMana:F0}/{manaSystem.MaxMana:F0}");
        }

        Log("Using skill: " + skill.skillName);
        StartCoroutine(ExecuteSkill(skill, slotIndex, target, groundTarget));
        return true;
    }

    /// <summary>
    /// –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–∫–∏–ª–ª –≤ –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã–π —Å–ª–æ—Ç (1-5)
    /// –í—ã–∑—ã–≤–∞–µ—Ç—Å—è –∏–∑ SkillManager –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞
    /// </summary>
    public void SetSkill(int slotNumber, SkillConfig skill)
    {
        if (slotNumber < 1 || slotNumber > 5)
        {
            Debug.LogError($"[SkillExecutor] ‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –Ω–æ–º–µ—Ä —Å–ª–æ—Ç–∞: {slotNumber}. –î–æ–ª–∂–µ–Ω –±—ã—Ç—å 1-5.");
            return;
        }

        int slotIndex = slotNumber - 1; // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º 1-5 –≤ 0-4

        // –†–∞—Å—à–∏—Ä—è–µ–º —Å–ø–∏—Å–æ–∫ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
        while (equippedSkills.Count <= slotIndex)
        {
            equippedSkills.Add(null);
        }

        equippedSkills[slotIndex] = skill;

        if (skill != null)
        {
            Log($"‚úÖ –°–∫–∏–ª–ª '{skill.skillName}' (ID: {skill.skillId}) —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ —Å–ª–æ—Ç {slotNumber}");
        }
        else
        {
            Log($"‚ö†Ô∏è –°–ª–æ—Ç {slotNumber} –æ—á–∏—â–µ–Ω (skill = null)");
        }
    }

    /// <summary>
    /// –ü–æ–ª—É—á–∏—Ç—å —Å–∫–∏–ª–ª –∏–∑ —Å–ª–æ—Ç–∞ (1-5)
    /// </summary>
    public SkillConfig GetSkill(int slotNumber)
    {
        if (slotNumber < 1 || slotNumber > 5)
        {
            Debug.LogError($"[SkillExecutor] ‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –Ω–æ–º–µ—Ä —Å–ª–æ—Ç–∞: {slotNumber}");
            return null;
        }

        int slotIndex = slotNumber - 1;
        if (slotIndex >= equippedSkills.Count)
        {
            return null;
        }

        return equippedSkills[slotIndex];
    }

    /// <summary>
    /// –û—á–∏—Å—Ç–∏—Ç—å –≤—Å–µ —Å–ª–æ—Ç—ã
    /// </summary>
    public void ClearAllSkills()
    {
        equippedSkills.Clear();
        cooldownTimers.Clear();
        Log("üßπ –í—Å–µ —Å–∫–∏–ª–ª—ã –æ—á–∏—â–µ–Ω—ã");
    }

    public float GetCooldown(int slotIndex)
    {
        return cooldownTimers.ContainsKey(slotIndex) ? cooldownTimers[slotIndex] : 0f;
    }

    private IEnumerator ExecuteSkill(SkillConfig skill, int slotIndex, Transform target, Vector3? groundTarget)
    {
        if (animator != null && !string.IsNullOrEmpty(skill.animationTrigger))
        {
            animator.SetTrigger(skill.animationTrigger);
        }

        if (skill.castTime > 0f)
        {
            yield return new WaitForSeconds(skill.castTime);
        }

        cooldownTimers[slotIndex] = skill.cooldown;

        switch (skill.skillType)
        {
            case SkillConfigType.ProjectileDamage:
            case SkillConfigType.DamageAndHeal: // Soul Drain –∏ –¥—Ä—É–≥–∏–µ –≤–∞–º–ø–∏—Ä–∏—á–µ—Å–∫–∏–µ —Å–∫–∏–ª–ª—ã
                ExecuteProjectile(skill, target, groundTarget);
                break;
            case SkillConfigType.AOEDamage:
                ExecuteAOEDamage(skill, target, groundTarget);
                break;
            case SkillConfigType.Movement:
                ExecuteMovement(skill, target, groundTarget);
                break;
            case SkillConfigType.Buff:
                ExecuteBuff(skill, target);
                break;
            case SkillConfigType.Heal:
                ExecuteHeal(skill, target);
                break;
            case SkillConfigType.Summon:
                ExecuteSummon(skill);
                break;
            case SkillConfigType.Transformation:
                ExecuteTransformation(skill);
                break;
        }
    }

    private void ExecuteProjectile(SkillConfig skill, Transform target, Vector3? groundTarget)
    {
        if (skill.projectilePrefab == null)
        {
            Log("No projectile prefab for " + skill.skillName);
            return;
        }

        // Multi-hit support (–Ω–∞–ø—Ä–∏–º–µ—Ä, Rain of Arrows)
        if (skill.customData != null && skill.customData.hitCount > 1)
        {
            StartCoroutine(ExecuteMultipleProjectiles(skill, target, groundTarget));
            return;
        }

        // Single projectile
        LaunchProjectile(skill, target, groundTarget);
    }

    private IEnumerator ExecuteMultipleProjectiles(SkillConfig skill, Transform target, Vector3? groundTarget)
    {
        int hitCount = skill.customData.hitCount;
        float hitDelay = skill.customData.hitDelay;

        Log("Multi-hit: " + hitCount + " projectiles with " + hitDelay + "s delay");

        for (int i = 0; i < hitCount; i++)
        {
            LaunchProjectile(skill, target, groundTarget);

            if (i < hitCount - 1)
            {
                yield return new WaitForSeconds(hitDelay);
            }
        }
    }

    private void LaunchProjectile(SkillConfig skill, Transform target, Vector3? groundTarget)
    {
        Vector3 spawnPos = transform.position + transform.forward * 1f + Vector3.up * 1.5f;
        Vector3 direction;

        if (target != null)
        {
            direction = (target.position - spawnPos).normalized;
        }
        else if (groundTarget.HasValue)
        {
            direction = (groundTarget.Value - spawnPos).normalized;
        }
        else
        {
            direction = transform.forward;
        }

        GameObject projectile = Instantiate(skill.projectilePrefab, spawnPos, Quaternion.LookRotation(direction));

        // üöÄ SYNC: Send projectile to other players
        string targetSocketId = "";
        if (target != null)
        {
            NetworkPlayer networkTarget = target.GetComponent<NetworkPlayer>();
            if (networkTarget != null)
            {
                targetSocketId = networkTarget.socketId;
            }
        }

        SocketIOManager socketIO = SocketIOManager.Instance;
        if (socketIO != null && socketIO.IsConnected)
        {
            socketIO.SendProjectileSpawned(skill.skillId, spawnPos, direction, targetSocketId);
            Log($"üåê Projectile synced to server: skillId={skill.skillId}");
        }

        // Try CelestialProjectile first (for mage)
        CelestialProjectile celestialProj = projectile.GetComponent<CelestialProjectile>();
        if (celestialProj != null)
        {
            float damage = CalculateDamage(skill);
            celestialProj.Initialize(target, damage, direction, gameObject, null, false, false);

            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º Life Steal –µ—Å–ª–∏ —Å–∫–∏–ª–ª –∏–º–µ–µ—Ç –≤–∞–º–ø–∏—Ä–∏–∑–º
            if (skill.lifeStealPercent > 0)
            {
                celestialProj.SetLifeSteal(skill.lifeStealPercent, skill.casterEffectPrefab);
                Log($"üßõ Life Steal –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω: {skill.lifeStealPercent}%");
            }

            Log("Projectile launched: " + damage + " damage");
        }
        else
        {
            // Try ArrowProjectile (for archer)
            ArrowProjectile arrowProj = projectile.GetComponent<ArrowProjectile>();
            if (arrowProj != null)
            {
                float damage = CalculateDamage(skill);
                arrowProj.InitializeWithEffects(target, damage, direction, gameObject, skill.effects, stats, false, false);
                Log("Arrow launched: " + damage + " damage");
            }
            else
            {
                // Try old Projectile component (EntanglingArrow, etc)
                Projectile oldProj = projectile.GetComponent<Projectile>();
                if (oldProj != null)
                {
                    float damage = CalculateDamage(skill);
                    oldProj.Initialize(target, damage, direction, gameObject, null);
                    
                    // Set hit effect from skill
                    if (skill.hitEffectPrefab != null)
                    {
                        oldProj.SetHitEffect(skill.hitEffectPrefab);
                    }
                    
                    Log("Old Projectile launched: " + damage + " damage");

                    // –ü—Ä–∏–º–µ–Ω—è–µ–º —ç—Ñ—Ñ–µ–∫—Ç—ã –≤—Ä—É—á–Ω—É—é (—Å—Ç–∞—Ä—ã–π Projectile –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç EffectConfig)
                    if (skill.effects != null && skill.effects.Count > 0)
                    {
                        // –î–æ–±–∞–≤–∏–º MonoBehaviour –¥–ª—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è —ç—Ñ—Ñ–µ–∫—Ç–æ–≤ –ø—Ä–∏ –ø–æ–ø–∞–¥–∞–Ω–∏–∏
                        ProjectileEffectApplier effectApplier = projectile.AddComponent<ProjectileEffectApplier>();
                        effectApplier.Initialize(skill.effects, stats);
                    }
                }
            }
        }

        // –≠—Ñ—Ñ–µ–∫—Ç –∫–∞—Å—Ç–∞ —Å–Ω–∞—Ä—è–¥–∞ (–Ω–∞ –∫–∞—Å—Ç–µ—Ä–µ)
        SpawnEffect(skill.castEffectPrefab, spawnPos, Quaternion.identity, 1f, "", "cast");
    }

    private void ExecuteAOEDamage(SkillConfig skill, Transform target, Vector3? groundTarget)
    {
        Vector3 aoeCenter;

        if (skill.targetType == SkillTargetType.Self || skill.targetType == SkillTargetType.NoTarget)
        {
            aoeCenter = transform.position;
        }
        else if (groundTarget.HasValue)
        {
            aoeCenter = groundTarget.Value;

            if (skill.skillName == "Meteor")
            {
                StartCoroutine(SpawnFallingMeteor(skill, aoeCenter));
                return;
            }
        }
        else if (target != null)
        {
            aoeCenter = target.position;
        }
        else
        {
            aoeCenter = transform.position + transform.forward * skill.aoeRadius;
        }

        Log("AOE center: " + aoeCenter + ", radius: " + skill.aoeRadius);

        Collider[] hits = Physics.OverlapSphere(aoeCenter, skill.aoeRadius, ~0);
        List<Transform> hitTargets = new List<Transform>();

        foreach (Collider hit in hits)
        {
            if (hit.transform == transform) continue;

            Enemy enemy = hit.GetComponent<Enemy>();
            DummyEnemy dummyEnemy = hit.GetComponent<DummyEnemy>();
            NetworkPlayer networkPlayer = hit.GetComponent<NetworkPlayer>();

            if (enemy != null || dummyEnemy != null || networkPlayer != null)
            {
                hitTargets.Add(hit.transform);

                if (hitTargets.Count >= skill.maxTargets && skill.maxTargets > 0)
                    break;
            }
        }

        Log("Found targets: " + hitTargets.Count);

        float damage = CalculateDamage(skill);

        foreach (Transform hitTarget in hitTargets)
        {
            Enemy enemy = hitTarget.GetComponent<Enemy>();
            DummyEnemy dummyEnemy = hitTarget.GetComponent<DummyEnemy>();
            NetworkPlayer networkPlayer = hitTarget.GetComponent<NetworkPlayer>();

            if (enemy != null)
            {
                enemy.TakeDamage(damage);
            }
            else if (dummyEnemy != null)
            {
                dummyEnemy.TakeDamage(damage);
            }

            if (skill.effects != null && skill.effects.Count > 0)
            {
                EffectManager targetEffectManager = hitTarget.GetComponent<EffectManager>();
                if (targetEffectManager != null)
                {
                    foreach (EffectConfig effect in skill.effects)
                    {
                        targetEffectManager.ApplyEffect(effect, stats);
                    }
                }
            }

            // –≠—Ñ—Ñ–µ–∫—Ç –ø–æ–ø–∞–¥–∞–Ω–∏—è –Ω–∞ —Ü–µ–ª–∏
            string targetSocketId = "";
            if (networkPlayer != null)
            {
                targetSocketId = networkPlayer.socketId;
            }
            SpawnEffect(skill.hitEffectPrefab, hitTarget.position, Quaternion.identity, 1f, targetSocketId, "hit");
        }

        // –≠—Ñ—Ñ–µ–∫—Ç –∫–∞—Å—Ç–∞ AOE –≤ —Ü–µ–Ω—Ç—Ä–µ
        SpawnEffect(skill.castEffectPrefab, aoeCenter, Quaternion.identity, 2f, "", "aoe");

        if (skill.customData != null && skill.customData.chainCount > 0 && hitTargets.Count > 0)
        {
            List<Transform> alreadyHit = new List<Transform>(hitTargets);
            ExecuteChainLightning(skill, hitTargets[0], damage, alreadyHit, 0);
        }
    }

    private void ExecuteChainLightning(SkillConfig skill, Transform fromTarget, float baseDamage, List<Transform> alreadyHitTargets, int currentChain)
    {
        if (currentChain >= skill.customData.chainCount)
        {
            Log("Chain lightning completed: " + currentChain + " jumps");
            return;
        }

        float chainDamage = baseDamage * Mathf.Pow(skill.customData.chainDamageMultiplier, currentChain + 1);

        Log("Chain lightning jump " + (currentChain + 1) + ": " + chainDamage + " damage");

        Collider[] nearbyTargets = Physics.OverlapSphere(fromTarget.position, skill.customData.chainRadius, ~0);

        Transform nextTarget = null;
        float closestDistance = float.MaxValue;

        foreach (Collider hit in nearbyTargets)
        {
            if (hit.transform == transform) continue;
            if (alreadyHitTargets.Contains(hit.transform)) continue;

            Enemy enemy = hit.GetComponent<Enemy>();
            DummyEnemy dummyEnemy = hit.GetComponent<DummyEnemy>();
            NetworkPlayer networkPlayer = hit.GetComponent<NetworkPlayer>();

            if (enemy == null && dummyEnemy == null && networkPlayer == null) continue;

            float distance = Vector3.Distance(fromTarget.position, hit.transform.position);
            if (distance < closestDistance)
            {
                closestDistance = distance;
                nextTarget = hit.transform;
            }
        }

        if (nextTarget == null)
        {
            Log("Chain lightning stopped: no targets in radius");
            return;
        }

        Enemy targetEnemy = nextTarget.GetComponent<Enemy>();
        DummyEnemy targetDummy = nextTarget.GetComponent<DummyEnemy>();

        if (targetEnemy != null)
        {
            targetEnemy.TakeDamage(chainDamage);
        }
        else if (targetDummy != null)
        {
            targetDummy.TakeDamage(chainDamage);
        }

        Log("Chain hit " + nextTarget.name + ": " + chainDamage + " damage");

        if (skill.effects != null && skill.effects.Count > 0)
        {
            EffectManager targetEffectManager = nextTarget.GetComponent<EffectManager>();
            if (targetEffectManager != null)
            {
                foreach (EffectConfig effect in skill.effects)
                {
                    targetEffectManager.ApplyEffect(effect, stats);
                }
            }
        }

        // –≠—Ñ—Ñ–µ–∫—Ç chain lightning –Ω–∞ —Å–ª–µ–¥—É—é—â–µ–π —Ü–µ–ª–∏
        string chainTargetSocketId = "";
        NetworkPlayer chainNetPlayer = nextTarget.GetComponent<NetworkPlayer>();
        if (chainNetPlayer != null)
        {
            chainTargetSocketId = chainNetPlayer.socketId;
        }
        SpawnEffect(skill.hitEffectPrefab, nextTarget.position, Quaternion.identity, 1f, chainTargetSocketId, "chain_hit");

        alreadyHitTargets.Add(nextTarget);

        ExecuteChainLightning(skill, nextTarget, baseDamage, alreadyHitTargets, currentChain + 1);
    }

    private void ExecuteMovement(SkillConfig skill, Transform target, Vector3? groundTarget)
    {
        if (!skill.enableMovement)
        {
            Log("Movement not enabled for " + skill.skillName);
            return;
        }

        Vector3 destination = CalculateMovementDestination(skill, target, groundTarget);

        Log("Movement to " + destination);

        switch (skill.movementType)
        {
            case MovementType.Dash:
            case MovementType.Charge:
                StartCoroutine(DashToPosition(destination, skill.movementSpeed));
                break;

            case MovementType.Teleport:
            case MovementType.Blink:
                CharacterController cc = GetComponent<CharacterController>();
                if (cc != null)
                {
                    cc.enabled = false;
                    transform.position = destination;
                    cc.enabled = true;
                }
                else
                {
                    transform.position = destination;
                }

                Log("Teleported to " + destination);

                // –≠—Ñ—Ñ–µ–∫—Ç —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞ –≤ —Ç–æ—á–∫–µ –ø—Ä–∏–±—ã—Ç–∏—è
                SpawnEffect(skill.hitEffectPrefab, destination, Quaternion.identity, 1f, "", "teleport_arrive");
                break;
        }

        // –≠—Ñ—Ñ–µ–∫—Ç –∫–∞—Å—Ç–∞ –¥–≤–∏–∂–µ–Ω–∏—è (–≤ —Ç–æ—á–∫–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∏—è)
        SpawnEffect(skill.castEffectPrefab, transform.position, Quaternion.identity, 1f, "", "movement_cast");

        // –ü—Ä–∏–º–µ–Ω—è–µ–º —ç—Ñ—Ñ–µ–∫—Ç—ã –Ω–∞ —Ü–µ–ª—å –ø–æ—Å–ª–µ —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, Stun –¥–ª—è Warrior Charge)
        if (target != null && skill.effects != null && skill.effects.Count > 0)
        {
            EffectManager targetEffectManager = target.GetComponent<EffectManager>();
            if (targetEffectManager != null)
            {
                foreach (EffectConfig effect in skill.effects)
                {
                    targetEffectManager.ApplyEffect(effect, stats);
                    Log("Effect applied to target: " + effect.effectType);
                }
            }
            else
            {
                Debug.LogWarning($"[SkillExecutor] Target {target.name} has no EffectManager!");
            }
        }
    }

    private IEnumerator DashToPosition(Vector3 destination, float speed)
    {
        Vector3 startPos = transform.position;
        float distance = Vector3.Distance(startPos, destination);
        float duration = distance / speed;
        float elapsed = 0f;

        while (elapsed < duration)
        {
            transform.position = Vector3.Lerp(startPos, destination, elapsed / duration);
            elapsed += Time.deltaTime;
            yield return null;
        }

        transform.position = destination;
    }

    private Vector3 CalculateMovementDestination(SkillConfig skill, Transform target, Vector3? groundTarget)
    {
        switch (skill.movementDirection)
        {
            case MovementDirection.Forward:
                return transform.position + transform.forward * skill.movementDistance;

            case MovementDirection.Backward:
                return transform.position - transform.forward * skill.movementDistance;

            case MovementDirection.ToTarget:
                if (target != null)
                {
                    // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –¥–∏—Å—Ç–∞–Ω—Ü–∏—é –¥–æ —Ü–µ–ª–∏
                    float distanceToTarget = Vector3.Distance(transform.position, target.position);

                    Log($"ToTarget: –¥–∏—Å—Ç–∞–Ω—Ü–∏—è –¥–æ —Ü–µ–ª–∏ = {distanceToTarget:F1}–º, –º–∞–∫—Å –¥–∏—Å—Ç–∞–Ω—Ü–∏—è = {skill.movementDistance}–º");

                    // –ï—Å–ª–∏ —Ü–µ–ª—å –±–ª–∏–∂–µ —á–µ–º movementDistance - —Ç–µ–ª–µ–ø–æ—Ä—Ç–∏—Ä—É–µ–º—Å—è –ü–†–Ø–ú–û –ö –ù–ï–ô
                    // –ï—Å–ª–∏ —Ü–µ–ª—å –¥–∞–ª—å—à–µ - —Ç–µ–ª–µ–ø–æ—Ä—Ç–∏—Ä—É–µ–º—Å—è –ù–ê movementDistance –ö –ù–ï–ô
                    if (distanceToTarget <= skill.movementDistance)
                    {
                        // –¢–µ–ª–µ–ø–æ—Ä—Ç –ø—Ä—è–º–æ –∫ –≤—Ä–∞–≥—É (–Ω–µ–º–Ω–æ–≥–æ –ø–µ—Ä–µ–¥ –Ω–∏–º –¥–ª—è –≤–∏–∑—É–∞–ª–∞)
                        Vector3 dirToTarget = (target.position - transform.position).normalized;
                        Vector3 destination = target.position - dirToTarget * 1.5f; // –ù–∞ 1.5–º –ø–µ—Ä–µ–¥ –≤—Ä–∞–≥–æ–º
                        Log($"‚ö° –¢–µ–ª–µ–ø–æ—Ä—Ç –ü–†–Ø–ú–û –ö –í–†–ê–ì–£! –ü–æ–∑–∏—Ü–∏—è –≤—Ä–∞–≥–∞: {target.position}, —Ç–æ—á–∫–∞ —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞: {destination}");
                        return destination;
                    }
                    else
                    {
                        // –¶–µ–ª—å –¥–∞–ª–µ–∫–æ - —Ç–µ–ª–µ–ø–æ—Ä—Ç–∏—Ä—É–µ–º—Å—è –Ω–∞ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –¥–∏—Å—Ç–∞–Ω—Ü–∏—é –∫ –Ω–µ–π
                        Vector3 dirToTarget = (target.position - transform.position).normalized;
                        Vector3 destination = transform.position + dirToTarget * skill.movementDistance;
                        Log($"‚ö° –¶–µ–ª—å –¥–∞–ª–µ–∫–æ! –¢–µ–ª–µ–ø–æ—Ä—Ç –Ω–∞ {skill.movementDistance}–º –∫ –≤—Ä–∞–≥—É. –¢–æ—á–∫–∞: {destination}");
                        return destination;
                    }
                }
                return transform.position + transform.forward * skill.movementDistance;

            case MovementDirection.MouseDirection:
                if (groundTarget.HasValue)
                {
                    return groundTarget.Value;
                }
                return transform.position + transform.forward * skill.movementDistance;

            default:
                return transform.position;
        }
    }

    private void ExecuteBuff(SkillConfig skill, Transform target)
    {
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // –°–ü–ï–¶–ò–ê–õ–¨–ù–ê–Ø –ú–ï–•–ê–ù–ò–ö–ê: Blood for Mana (–∂–µ—Ä—Ç–≤–µ–Ω–Ω–æ–µ –∑–∞–∫–ª–∏–Ω–∞–Ω–∏–µ)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        if (skill.customData != null && skill.customData.manaRestorePercent > 0)
        {
            ExecuteBloodForMana(skill);
            return;
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // AOE BUFF (Divine Protection –∏ –¥—Ä—É–≥–∏–µ –≥—Ä—É–ø–ø–æ–≤—ã–µ –±–∞—Ñ—Ñ—ã)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        if (skill.aoeRadius > 0 && (skill.targetType == SkillTargetType.NoTarget || skill.targetType == SkillTargetType.Self))
        {
            ExecuteAOEBuff(skill);
            return;
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // –û–î–ò–ù–û–ß–ù–´–ô –ë–ê–§–§ (–Ω–∞ –æ–¥–Ω—É —Ü–µ–ª—å)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        Transform buffTarget = (skill.targetType == SkillTargetType.Self) ? transform : target;

        if (buffTarget == null)
        {
            Log("Buff target missing");
            return;
        }

        EffectManager targetEffectManager = buffTarget.GetComponent<EffectManager>();
        if (targetEffectManager != null && skill.effects != null)
        {
            foreach (EffectConfig effect in skill.effects)
            {
                targetEffectManager.ApplyEffect(effect, stats);
                Log("Buff applied: " + effect.effectType);
            }
        }

        // –≠—Ñ—Ñ–µ–∫—Ç –±–∞—Ñ—Ñ –∫–∞—Å—Ç–∞ –Ω–∞ —Ü–µ–ª–∏
        string buffTargetSocketId = "";
        NetworkPlayer buffNetPlayer = buffTarget.GetComponent<NetworkPlayer>();
        if (buffNetPlayer != null)
        {
            buffTargetSocketId = buffNetPlayer.socketId;
        }
        SpawnEffect(skill.castEffectPrefab, buffTarget.position, Quaternion.identity, 1f, buffTargetSocketId, "buff");
    }

    /// <summary>
    /// –ü—Ä–∏–º–µ–Ω–∏—Ç—å AOE –±–∞—Ñ—Ñ –Ω–∞ –≤—Å–µ—Ö —Å–æ—é–∑–Ω–∏–∫–æ–≤ –≤ —Ä–∞–¥–∏—É—Å–µ (Divine Protection, Group Heal –∏ —Ç.–¥.)
    /// </summary>
    private void ExecuteAOEBuff(SkillConfig skill)
    {
        Vector3 center = transform.position;
        Log($"AOE Buff center: {center}, radius: {skill.aoeRadius}");

        // –°–ø–∞–≤–Ω–∏–º —ç—Ñ—Ñ–µ–∫—Ç –∫–∞—Å—Ç–∞ –Ω–∞ –∫–∞—Å—Ç–µ—Ä–µ (AOE Buff –Ω–∞—á–∞–ª–æ)
        SpawnEffect(skill.castEffectPrefab, center, Quaternion.identity, 2f, "", "aoe_buff_cast");
        SpawnEffect(skill.casterEffectPrefab, center + Vector3.up * 1.5f, Quaternion.identity, 2f, "", "aoe_buff_aura");

        // –ò—â–µ–º –≤—Å–µ—Ö –≤ —Ä–∞–¥–∏—É—Å–µ
        Collider[] hits = Physics.OverlapSphere(center, skill.aoeRadius, ~0);
        List<Transform> allies = new List<Transform>();

        foreach (Collider hit in hits)
        {
            if (hit.transform == transform)
            {
                // –°–∞–º –∫–∞—Å—Ç–µ—Ä - –≤—Å–µ–≥–¥–∞ —Å–æ—é–∑–Ω–∏–∫
                allies.Add(transform);
                continue;
            }

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —ç—Ç–æ —Å–æ—é–∑–Ω–∏–∫ –∏–ª–∏ –≤—Ä–∞–≥
            // TODO: –î–æ–±–∞–≤–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É –∫–æ–º–∞–Ω–¥—ã –∫–æ–≥–¥–∞ –±—É–¥–µ—Ç —Å–∏—Å—Ç–µ–º–∞ –∫–æ–º–∞–Ω–¥
            // –ü–æ–∫–∞ —Å—á–∏—Ç–∞–µ–º —Å–æ—é–∑–Ω–∏–∫–∞–º–∏ –≤—Å–µ—Ö –∏–≥—Ä–æ–∫–æ–≤ (NetworkPlayer, SimplePlayerController)

            bool isAlly = false;

            // –õ–æ–∫–∞–ª—å–Ω—ã–π –∏–≥—Ä–æ–∫
            SimplePlayerController localPlayer = hit.GetComponent<SimplePlayerController>();
            if (localPlayer != null)
            {
                isAlly = true;
            }

            // –°–µ—Ç–µ–≤—ã–µ –∏–≥—Ä–æ–∫–∏
            NetworkPlayer networkPlayer = hit.GetComponent<NetworkPlayer>();
            if (networkPlayer != null)
            {
                // TODO: –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∫–æ–º–∞–Ω–¥—É —á–µ—Ä–µ–∑ networkPlayer.teamId
                isAlly = true;
            }

            // PlayerController (–¥–ª—è –∞—Ä–µ–Ω—ã)
            PlayerController playerController = hit.GetComponent<PlayerController>();
            if (playerController != null)
            {
                isAlly = true;
            }

            if (isAlly)
            {
                allies.Add(hit.transform);

                if (allies.Count >= skill.maxTargets && skill.maxTargets > 0)
                    break;
            }
        }

        Log($"Found {allies.Count} allies in radius");

        // –ü—Ä–∏–º–µ–Ω—è–µ–º –±–∞—Ñ—Ñ—ã –Ω–∞ –≤—Å–µ—Ö —Å–æ—é–∑–Ω–∏–∫–æ–≤
        foreach (Transform ally in allies)
        {
            EffectManager effectManager = ally.GetComponent<EffectManager>();
            if (effectManager != null && skill.effects != null)
            {
                foreach (EffectConfig effect in skill.effects)
                {
                    effectManager.ApplyEffect(effect, stats);
                    Log($"‚úÖ Buff {effect.effectType} applied to {ally.name}");
                }
            }

            // –°–ø–∞–≤–Ω–∏–º –≤–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç –Ω–∞ —Å–æ—é–∑–Ω–∏–∫–µ
            string allySocketId = "";
            NetworkPlayer allyNetPlayer = ally.GetComponent<NetworkPlayer>();
            if (allyNetPlayer != null)
            {
                allySocketId = allyNetPlayer.socketId;
            }
            SpawnEffect(skill.hitEffectPrefab, ally.position, Quaternion.identity, 1.5f, allySocketId, "buff_ally");
        }
    }

    private void ExecuteHeal(SkillConfig skill, Transform target)
    {
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // AOE HEAL (Lay on Hands –∏ –¥—Ä—É–≥–∏–µ –≥—Ä—É–ø–ø–æ–≤—ã–µ —Ö–∏–ª—ã)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        if (skill.aoeRadius > 0 && (skill.targetType == SkillTargetType.NoTarget || skill.targetType == SkillTargetType.Self))
        {
            ExecuteAOEHeal(skill);
            return;
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // –û–î–ò–ù–û–ß–ù–´–ô –•–ò–õ (–Ω–∞ –æ–¥–Ω—É —Ü–µ–ª—å)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        Transform healTarget = (skill.targetType == SkillTargetType.Self) ? transform : target;

        if (healTarget == null)
        {
            Log("Heal target missing");
            return;
        }

        float healAmount = CalculateHeal(skill);

        // –ï—Å–ª–∏ healAmount –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–µ - —ç—Ç–æ –ø—Ä–æ—Ü–µ–Ω—Ç –æ—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ HP
        HealthSystem targetHealthSystem = healTarget.GetComponent<HealthSystem>();
        if (targetHealthSystem != null)
        {
            if (healAmount < 0)
            {
                // –û—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ = –ø—Ä–æ—Ü–µ–Ω—Ç –æ—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ HP
                float percentHeal = Mathf.Abs(healAmount);
                float actualHeal = targetHealthSystem.MaxHealth * (percentHeal / 100f);
                targetHealthSystem.Heal(actualHeal);
                Log($"‚öïÔ∏è –õ–µ—á–µ–Ω–∏–µ {healTarget.name}: {actualHeal:F1} HP ({percentHeal}% –æ—Ç {targetHealthSystem.MaxHealth:F0})");
            }
            else
            {
                // –ü–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ = —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –ª–µ—á–µ–Ω–∏–µ
                targetHealthSystem.Heal(healAmount);
                Log($"‚öïÔ∏è –õ–µ—á–µ–Ω–∏–µ {healTarget.name}: {healAmount:F1} HP");
            }
        }

        // –í–∏–∑—É–∞–ª—å–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã –ª–µ—á–µ–Ω–∏—è
        string healTargetSocketId = "";
        NetworkPlayer healNetPlayer = healTarget.GetComponent<NetworkPlayer>();
        if (healNetPlayer != null)
        {
            healTargetSocketId = healNetPlayer.socketId;
        }
        SpawnEffect(skill.castEffectPrefab, healTarget.position, Quaternion.identity, 1f, healTargetSocketId, "heal_cast");
        SpawnEffect(skill.hitEffectPrefab, healTarget.position, Quaternion.identity, 2f, healTargetSocketId, "heal_effect");
    }

    /// <summary>
    /// –ü—Ä–∏–º–µ–Ω–∏—Ç—å AOE —Ö–∏–ª –Ω–∞ –≤—Å–µ—Ö —Å–æ—é–∑–Ω–∏–∫–æ–≤ –≤ —Ä–∞–¥–∏—É—Å–µ (Lay on Hands, Group Heal –∏ —Ç.–¥.)
    /// </summary>
    private void ExecuteAOEHeal(SkillConfig skill)
    {
        Vector3 center = transform.position;
        Log($"AOE Heal center: {center}, radius: {skill.aoeRadius}");

        // –°–ø–∞–≤–Ω–∏–º —ç—Ñ—Ñ–µ–∫—Ç –∫–∞—Å—Ç–∞ –Ω–∞ –∫–∞—Å—Ç–µ—Ä–µ (AOE Heal –Ω–∞—á–∞–ª–æ)
        SpawnEffect(skill.castEffectPrefab, center, Quaternion.identity, 2f, "", "aoe_heal_cast");
        SpawnEffect(skill.casterEffectPrefab, center + Vector3.up * 1.5f, Quaternion.identity, 2f, "", "aoe_heal_aura");

        // –ò—â–µ–º –≤—Å–µ—Ö –≤ —Ä–∞–¥–∏—É—Å–µ
        Collider[] hits = Physics.OverlapSphere(center, skill.aoeRadius, ~0);
        List<Transform> allies = new List<Transform>();

        foreach (Collider hit in hits)
        {
            if (hit.transform == transform)
            {
                // –°–∞–º –∫–∞—Å—Ç–µ—Ä - –≤—Å–µ–≥–¥–∞ —Å–æ—é–∑–Ω–∏–∫
                allies.Add(transform);
                continue;
            }

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —ç—Ç–æ —Å–æ—é–∑–Ω–∏–∫
            bool isAlly = false;

            // –õ–æ–∫–∞–ª—å–Ω—ã–π –∏–≥—Ä–æ–∫
            SimplePlayerController localPlayer = hit.GetComponent<SimplePlayerController>();
            if (localPlayer != null)
            {
                isAlly = true;
            }

            // –°–µ—Ç–µ–≤—ã–µ –∏–≥—Ä–æ–∫–∏
            NetworkPlayer networkPlayer = hit.GetComponent<NetworkPlayer>();
            if (networkPlayer != null)
            {
                isAlly = true;
            }

            // PlayerController (–¥–ª—è –∞—Ä–µ–Ω—ã)
            PlayerController playerController = hit.GetComponent<PlayerController>();
            if (playerController != null)
            {
                isAlly = true;
            }

            if (isAlly)
            {
                allies.Add(hit.transform);

                if (allies.Count >= skill.maxTargets && skill.maxTargets > 0)
                    break;
            }
        }

        Log($"Found {allies.Count} allies to heal");

        float baseHealAmount = CalculateHeal(skill);

        // –õ–µ—á–∏–º –≤—Å–µ—Ö —Å–æ—é–∑–Ω–∏–∫–æ–≤
        foreach (Transform ally in allies)
        {
            HealthSystem healthSystem = ally.GetComponent<HealthSystem>();
            if (healthSystem != null)
            {
                float actualHeal;

                if (baseHealAmount < 0)
                {
                    // –û—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ = –ø—Ä–æ—Ü–µ–Ω—Ç –æ—Ç MaxHP –ö–ê–ñ–î–û–ì–û —Å–æ—é–∑–Ω–∏–∫–∞
                    float percentHeal = Mathf.Abs(baseHealAmount);
                    actualHeal = healthSystem.MaxHealth * (percentHeal / 100f);
                    healthSystem.Heal(actualHeal);
                    Log($"‚öïÔ∏è –õ–µ—á–µ–Ω–∏–µ {ally.name}: {actualHeal:F1} HP ({percentHeal}% –æ—Ç {healthSystem.MaxHealth:F0})");
                }
                else
                {
                    // –ü–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ = —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –ª–µ—á–µ–Ω–∏–µ
                    actualHeal = baseHealAmount;
                    healthSystem.Heal(actualHeal);
                    Log($"‚öïÔ∏è –õ–µ—á–µ–Ω–∏–µ {ally.name}: {actualHeal:F1} HP");
                }
            }

            // –°–ø–∞–≤–Ω–∏–º –≤–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç –Ω–∞ —Å–æ—é–∑–Ω–∏–∫–µ
            string healAllySocketId = "";
            NetworkPlayer healAllyNetPlayer = ally.GetComponent<NetworkPlayer>();
            if (healAllyNetPlayer != null)
            {
                healAllySocketId = healAllyNetPlayer.socketId;
            }
            SpawnEffect(skill.hitEffectPrefab, ally.position, Quaternion.identity, 1.5f, healAllySocketId, "heal_ally");
        }
    }

    /// <summary>
    /// –í—ã–ø–æ–ª–Ω–∏—Ç—å Blood for Mana (–∂–µ—Ä—Ç–≤–µ–Ω–Ω–æ–µ –∑–∞–∫–ª–∏–Ω–∞–Ω–∏–µ)
    /// –ñ–µ—Ä—Ç–≤—É–µ—Ç 20% HP –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è 20% –º–∞–Ω—ã
    /// </summary>
    private void ExecuteBloodForMana(SkillConfig skill)
    {
        // –ü–æ–ª—É—á–∞–µ–º HealthSystem –∏ ManaSystem
        HealthSystem healthSystem = GetComponent<HealthSystem>();
        ManaSystem manaSystem = GetComponent<ManaSystem>();

        if (healthSystem == null)
        {
            Log("‚ùå HealthSystem –Ω–µ –Ω–∞–π–¥–µ–Ω! Blood for Mana –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω");
            return;
        }

        if (manaSystem == null)
        {
            Log("‚ùå ManaSystem –Ω–µ –Ω–∞–π–¥–µ–Ω! Blood for Mana –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω");
            return;
        }

        // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —É—Ä–æ–Ω —Å–µ–±–µ (–ø—Ä–æ—Ü–µ–Ω—Ç –æ—Ç MaxHP)
        float hpSacrifice = 0f;
        if (skill.baseDamageOrHeal < 0)
        {
            // –û—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ = –ø—Ä–æ—Ü–µ–Ω—Ç –æ—Ç MaxHP
            float sacrificePercent = Mathf.Abs(skill.baseDamageOrHeal);
            hpSacrifice = healthSystem.MaxHealth * (sacrificePercent / 100f);
            Log($"ü©∏ –ñ–µ—Ä—Ç–≤—É–µ–º {sacrificePercent}% HP ({hpSacrifice:F1} HP)");
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —É –Ω–∞—Å –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ HP (–Ω–µ –º–æ–∂–µ–º —É–±–∏—Ç—å —Å–µ–±—è)
        if (healthSystem.CurrentHealth <= hpSacrifice)
        {
            Log($"‚ö†Ô∏è –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ HP! –ù—É–∂–Ω–æ –±–æ–ª—å—à–µ {hpSacrifice:F0} HP –¥–ª—è –∂–µ—Ä—Ç–≤—ã");
            return;
        }

        // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –º–∞–Ω—ã
        float manaRestore = manaSystem.MaxMana * (skill.customData.manaRestorePercent / 100f);

        // –ñ–µ—Ä—Ç–≤—É–µ–º HP
        healthSystem.TakeDamage(hpSacrifice);
        Log($"ü©∏ –ñ–µ—Ä—Ç–≤–∞: -{hpSacrifice:F1} HP (–æ—Å—Ç–∞–ª–æ—Å—å: {healthSystem.CurrentHealth:F0}/{healthSystem.MaxHealth:F0})");

        // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –º–∞–Ω—É
        manaSystem.RestoreMana(manaRestore);
        Log($"üíô –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ: +{manaRestore:F1} MP ({skill.customData.manaRestorePercent}% –æ—Ç –º–∞–∫—Å–∏–º—É–º–∞)");

        // –í–∏–∑—É–∞–ª—å–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã Blood for Mana
        SpawnEffect(skill.castEffectPrefab, transform.position, Quaternion.identity, 1.5f, "", "blood_sacrifice"); // –ö—Ä–æ–≤–∞–≤—ã–π —ç—Ñ—Ñ–µ–∫—Ç
        SpawnEffect(skill.casterEffectPrefab, transform.position + Vector3.up * 1.5f, Quaternion.identity, 2f, "", "mana_restore"); // –≠—Ñ—Ñ–µ–∫—Ç –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –º–∞–Ω—ã

        Log($"‚úÖ Blood for Mana: -{hpSacrifice:F0} HP ‚Üí +{manaRestore:F0} MP");
    }

    private float CalculateDamage(SkillConfig skill)
    {
        float damage = skill.baseDamageOrHeal;

        if (stats != null)
        {
            if (skill.strengthScaling > 0f)
            {
                damage += stats.GetStat("Strength") * skill.strengthScaling;
            }

            if (skill.intelligenceScaling > 0f)
            {
                damage += stats.GetStat("Intelligence") * skill.intelligenceScaling;
            }

            // –ü—Ä–∏–º–µ–Ω—è–µ–º –º–æ–¥–∏—Ñ–∏–∫–∞—Ç–æ—Ä –∞—Ç–∞–∫–∏ (–æ—Ç Battle Rage –∏ –¥—Ä—É–≥–∏—Ö –±–∞—Ñ—Ñ–æ–≤)
            if (stats.AttackModifier > 0)
            {
                float bonus = damage * (stats.AttackModifier / 100f);
                damage += bonus;
                Log($"‚öîÔ∏è Attack modifier applied: +{stats.AttackModifier}% (+{bonus:F1} damage, total: {damage:F1})");
            }
        }

        Log("Damage calculated: " + damage + " (base: " + skill.baseDamageOrHeal + ")");
        return damage;
    }

    private float CalculateHeal(SkillConfig skill)
    {
        float heal = skill.baseDamageOrHeal;

        if (stats != null)
        {

            if (skill.intelligenceScaling > 0f)
            {
                heal += stats.GetStat("Intelligence") * skill.intelligenceScaling;
            }
        }

        return heal;
    }

    private void SpawnEffect(GameObject effectPrefab, Vector3 position, Quaternion rotation, float lifetime = 1f, string targetSocketId = "", string effectType = "effect")
    {
        if (effectPrefab == null) return;

        // –°–æ–∑–¥–∞—ë–º —ç—Ñ—Ñ–µ–∫—Ç –ª–æ–∫–∞–ª—å–Ω–æ
        GameObject effect = Instantiate(effectPrefab, position, rotation);
        Destroy(effect, lifetime);

        // üåê –°–ò–ù–•–†–û–ù–ò–ó–ê–¶–ò–Ø: –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç –Ω–∞ —Å–µ—Ä–≤–µ—Ä –¥–ª—è –¥—Ä—É–≥–∏—Ö –∏–≥—Ä–æ–∫–æ–≤
        if (SocketIOManager.Instance != null && SocketIOManager.Instance.IsConnected)
        {
            string prefabName = effectPrefab.name.Replace("(Clone)", "").Trim();
            SocketIOManager.Instance.SendVisualEffect(
                effectType,         // "cast", "hit", "buff", "explosion" –∏ —Ç.–¥.
                prefabName,         // –ò–º—è –ø—Ä–µ—Ñ–∞–±–∞ –¥–ª—è –ø–æ–∏—Å–∫–∞ –≤ Resources
                position,           // –ü–æ–∑–∏—Ü–∏—è —ç—Ñ—Ñ–µ–∫—Ç–∞
                rotation,           // –ü–æ–≤–æ—Ä–æ—Ç —ç—Ñ—Ñ–µ–∫—Ç–∞
                targetSocketId,     // –ï—Å–ª–∏ –ø—Ä–∏–≤—è–∑–∞–Ω –∫ –∏–≥—Ä–æ–∫—É (–ø—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞ = world space)
                lifetime            // –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —ç—Ñ—Ñ–µ–∫—Ç–∞
            );
            Log($"üåê –í–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ —Å–µ—Ä–≤–µ—Ä: {prefabName} at {position}");
        }
    }

    private IEnumerator SpawnFallingMeteor(SkillConfig skill, Vector3 targetPosition)
    {
        Vector3 skyPosition = targetPosition + Vector3.up * 30f;

        Log("Spawning meteor in sky: " + skyPosition);

        GameObject meteor = Instantiate(skill.projectilePrefab, skyPosition, Quaternion.identity);

        if (meteor == null)
        {
            Log("Failed to create meteor! Prefab: " + skill.projectilePrefab?.name);
            yield break;
        }

        Log("Meteor created: " + meteor.name + ", position: " + meteor.transform.position + ", scale: " + meteor.transform.localScale);

        meteor.transform.localScale = meteor.transform.localScale * 5f;

        Log("Scale increased to: " + meteor.transform.localScale);

        CelestialProjectile projectileScript = meteor.GetComponent<CelestialProjectile>();
        if (projectileScript != null)
        {
            projectileScript.enabled = false;
            Log("CelestialProjectile disabled");
        }

        TrailRenderer trail = meteor.GetComponent<TrailRenderer>();
        if (trail != null)
        {
            trail.time = 0.3f;
            trail.startWidth = 10f;
            trail.endWidth = 2f;

            Gradient gradient = new Gradient();
            gradient.SetKeys(
                new GradientColorKey[] {
                    new GradientColorKey(new Color(1f, 0.3f, 0f), 0.0f),
                    new GradientColorKey(new Color(1f, 0f, 0f), 0.5f),
                    new GradientColorKey(new Color(0.5f, 0f, 0f), 1.0f)
                },
                new GradientAlphaKey[] {
                    new GradientAlphaKey(1.0f, 0.0f),
                    new GradientAlphaKey(0.5f, 1.0f)
                }
            );
            trail.colorGradient = gradient;

            Log("Trail configured: time=" + trail.time + ", width=" + trail.startWidth + ", red color");
        }
        else
        {
            Log("TrailRenderer not found on meteor!");
        }

        GameObject fireEffect = Resources.Load<GameObject>("Effects/CFXR Fire");
        if (fireEffect != null)
        {
            GameObject fire = Instantiate(fireEffect, meteor.transform);
            fire.transform.localPosition = Vector3.zero;
            fire.transform.localScale = Vector3.one * 2f;
            Log("Fire effect added to meteor");
        }

        Light light = meteor.GetComponent<Light>();
        if (light != null)
        {
            light.color = new Color(1f, 0.3f, 0f);
            light.intensity = 5f;
            light.range = 30f;
        }

        float fallDuration = 1.2f;
        float elapsed = 0f;

        Log("Meteor falling from " + skyPosition + " to " + targetPosition);

        while (elapsed < fallDuration)
        {
            meteor.transform.position = Vector3.Lerp(skyPosition, targetPosition, elapsed / fallDuration);
            meteor.transform.Rotate(Vector3.forward * 360f * Time.deltaTime * 2f);
            elapsed += Time.deltaTime;
            yield return null;
        }

        meteor.transform.position = targetPosition;

        Log("Meteor reached ground: " + targetPosition);

        Collider[] hits = Physics.OverlapSphere(targetPosition, skill.aoeRadius, ~0);
        List<Transform> hitTargets = new List<Transform>();

        foreach (Collider hit in hits)
        {
            Enemy enemy = hit.GetComponent<Enemy>();
            DummyEnemy dummyEnemy = hit.GetComponent<DummyEnemy>();
            NetworkPlayer networkPlayer = hit.GetComponent<NetworkPlayer>();

            if (enemy != null || dummyEnemy != null || networkPlayer != null)
            {
                hitTargets.Add(hit.transform);

                if (hitTargets.Count >= skill.maxTargets && skill.maxTargets > 0)
                    break;
            }
        }

        float damage = CalculateDamage(skill);

        foreach (Transform hitTarget in hitTargets)
        {
            Enemy enemy = hitTarget.GetComponent<Enemy>();
            DummyEnemy dummyEnemy = hitTarget.GetComponent<DummyEnemy>();
            NetworkPlayer networkPlayer = hitTarget.GetComponent<NetworkPlayer>();

            if (enemy != null)
            {
                enemy.TakeDamage(damage);
            }
            else if (dummyEnemy != null)
            {
                dummyEnemy.TakeDamage(damage);
            }

            if (skill.effects != null && skill.effects.Count > 0)
            {
                EffectManager targetEffectManager = hitTarget.GetComponent<EffectManager>();
                if (targetEffectManager != null)
                {
                    foreach (EffectConfig effect in skill.effects)
                    {
                        targetEffectManager.ApplyEffect(effect, stats);
                        Log("Burn applied to " + hitTarget.name);
                    }
                }
            }

            // –≠—Ñ—Ñ–µ–∫—Ç –ø–æ–ø–∞–¥–∞–Ω–∏—è –º–µ—Ç–µ–æ—Ä–∞
            string meteorTargetSocketId = "";
            NetworkPlayer meteorNetPlayer = hitTarget.GetComponent<NetworkPlayer>();
            if (meteorNetPlayer != null)
            {
                meteorTargetSocketId = meteorNetPlayer.socketId;
            }
            SpawnEffect(skill.hitEffectPrefab, hitTarget.position, Quaternion.identity, 1f, meteorTargetSocketId, "meteor_hit");
        }

        // –≠—Ñ—Ñ–µ–∫—Ç –≤–∑—Ä—ã–≤–∞ –º–µ—Ç–µ–æ—Ä–∞ –≤ —Ç–æ—á–∫–µ –ø–∞–¥–µ–Ω–∏—è
        SpawnEffect(skill.castEffectPrefab, targetPosition, Quaternion.identity, 3f, "", "meteor_explosion");

        Destroy(meteor, 0.2f);

        Log("Meteor fell on " + targetPosition + ", damage " + damage + " to " + hitTargets.Count + " targets");
    }

    /// <summary>
    /// –ü—Ä–∏–∑—ã–≤ –º–∏–Ω—å–æ–Ω–∞ (Raise Dead)
    /// </summary>
    private void ExecuteSummon(SkillConfig skill)
    {
        Log($"Using skill: {skill.skillName}");

        // –°–ø–∞–≤–Ω–∏–º –≤–∏–∑—É–∞–ª—å–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã –ø—Ä–∏–∑—ã–≤–∞ –º–∏–Ω—å–æ–Ω–∞
        SpawnEffect(skill.castEffectPrefab, transform.position, Quaternion.identity, 2f, "", "summon_cast");
        SpawnEffect(skill.casterEffectPrefab, transform.position, Quaternion.identity, 2f, "", "summon_aura");

        // –ü–æ–ª—É—á–∞–µ–º duration –∏–∑ —ç—Ñ—Ñ–µ–∫—Ç–∞
        float summonDuration = 20f; // default
        if (skill.effects != null && skill.effects.Count > 0)
        {
            foreach (var effect in skill.effects)
            {
                if (effect.effectType == EffectType.SummonMinion)
                {
                    summonDuration = effect.duration;
                    break;
                }
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // –°–ò–°–¢–ï–ú–ê –ü–†–ò–ó–´–í–ê –ú–ò–ù–¨–û–ù–û–í
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        // 1. –ü—Ä–æ–≤–µ—Ä–∫–∞ - –µ—Å—Ç—å –ª–∏ —É–∂–µ –∞–∫—Ç–∏–≤–Ω—ã–π –º–∏–Ω—å–æ–Ω
        if (activeMinion != null)
        {
            Log($"‚ö†Ô∏è –°—Ç–∞—Ä—ã–π –º–∏–Ω—å–æ–Ω —É–Ω–∏—á—Ç–æ–∂–∞–µ—Ç—Å—è");
            Destroy(activeMinion);
            activeMinion = null;
        }

        // 2. –ó–∞–≥—Ä—É–∂–∞–µ–º –ø—Ä–µ—Ñ–∞–± —Å–∫–µ–ª–µ—Ç–∞
        GameObject skeletonPrefab = Resources.Load<GameObject>("Minions/Skeleton");
        if (skeletonPrefab == null)
        {
            Log($"‚ùå Skeleton prefab –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ Resources/Minions/Skeleton!");
            return;
        }

        // 3. –ü–æ–∑–∏—Ü–∏—è —Å–ø–∞–≤–Ω–∞ (–ø–µ—Ä–µ–¥ –Ω–µ–∫—Ä–æ–º–∞–Ω—Ç–æ–º)
        Vector3 spawnPosition = transform.position + transform.forward * 2f;
        spawnPosition.y = transform.position.y; // –û–¥–∏–Ω–∞–∫–æ–≤–∞—è –≤—ã—Å–æ—Ç–∞

        // 4. –°–æ–∑–¥–∞—ë–º —Å–∫–µ–ª–µ—Ç–∞
        activeMinion = Instantiate(skeletonPrefab, spawnPosition, transform.rotation);
        activeMinion.name = "Skeleton (Summoned)";

        // 4.5. –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏ –∫–æ–ø–∏—Ä—É–µ–º –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã —Å –ø—Ä–µ—Ñ–∞–±–∞
        SetupSkeletonComponents(activeMinion, skeletonPrefab);

        // 5. –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º AI
        SkeletonAI skeletonAI = activeMinion.GetComponent<SkeletonAI>();
        if (skeletonAI == null)
        {
            skeletonAI = activeMinion.AddComponent<SkeletonAI>();
        }

        CharacterStats casterStats = GetComponent<CharacterStats>();
        skeletonAI.Initialize(
            gameObject,                     // owner (–Ω–µ–∫—Ä–æ–º–∞–Ω—Ç)
            casterStats,                    // stats –Ω–µ–∫—Ä–æ–º–∞–Ω—Ç–∞
            skill.baseDamageOrHeal,         // –±–∞–∑–æ–≤—ã–π —É—Ä–æ–Ω (30)
            skill.intelligenceScaling,      // —Å–∫–µ–π–ª–∏–Ω–≥ INT (0.5)
            summonDuration                  // –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å (20 —Å–µ–∫)
        );

        Log($"üíÄ Raise Dead: –º–∏–Ω—å–æ–Ω –ø—Ä–∏–∑–≤–∞–Ω –Ω–∞ {summonDuration} —Å–µ–∫—É–Ω–¥");
        Log($"‚öîÔ∏è –£—Ä–æ–Ω –º–∏–Ω—å–æ–Ω–∞: {skill.baseDamageOrHeal} + {skill.intelligenceScaling * 100}% INT");
        Log($"üìç –ü–æ–∑–∏—Ü–∏—è —Å–ø–∞–≤–Ω–∞: {spawnPosition}");

        // –ü—Ä–∏–º–µ–Ω—è–µ–º —ç—Ñ—Ñ–µ–∫—Ç SummonMinion —á–µ—Ä–µ–∑ EffectManager (–¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è)
        if (skill.effects != null && skill.effects.Count > 0)
        {
            EffectManager effectManager = GetComponent<EffectManager>();
            if (effectManager == null)
            {
                effectManager = gameObject.AddComponent<EffectManager>();
            }

            CharacterStats stats = GetComponent<CharacterStats>();
            foreach (var effect in skill.effects)
            {
                if (effect.effectType == EffectType.SummonMinion)
                {
                    effectManager.ApplyEffect(effect, stats);
                }
            }
        }
    }

    /// <summary>
    /// –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ —Å–∫–µ–ª–µ—Ç–∞ (Animator, Collider, etc)
    /// </summary>
    private void SetupSkeletonComponents(GameObject skeleton, GameObject prefab)
    {
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ANIMATOR
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        Animator skeletonAnimator = skeleton.GetComponent<Animator>();
        Animator prefabAnimator = prefab.GetComponent<Animator>();

        if (skeletonAnimator == null && prefabAnimator != null)
        {
            // –ö–æ–ø–∏—Ä—É–µ–º Animator —Å –ø—Ä–µ—Ñ–∞–±–∞
            skeletonAnimator = skeleton.AddComponent<Animator>();
            skeletonAnimator.runtimeAnimatorController = prefabAnimator.runtimeAnimatorController;
            skeletonAnimator.avatar = prefabAnimator.avatar;
            skeletonAnimator.applyRootMotion = prefabAnimator.applyRootMotion;
            Log($"‚úÖ Animator —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω —Å –ø—Ä–µ—Ñ–∞–±–∞");
        }
        else if (skeletonAnimator != null && skeletonAnimator.runtimeAnimatorController == null)
        {
            // Animator –µ—Å—Ç—å, –Ω–æ Controller –Ω–µ –Ω–∞–∑–Ω–∞—á–µ–Ω - –∫–æ–ø–∏—Ä—É–µ–º —Å –ø—Ä–µ—Ñ–∞–±–∞
            if (prefabAnimator != null && prefabAnimator.runtimeAnimatorController != null)
            {
                skeletonAnimator.runtimeAnimatorController = prefabAnimator.runtimeAnimatorController;
                skeletonAnimator.avatar = prefabAnimator.avatar;
                skeletonAnimator.applyRootMotion = prefabAnimator.applyRootMotion;
                Log($"‚úÖ Animator Controller –Ω–∞–∑–Ω–∞—á–µ–Ω: {skeletonAnimator.runtimeAnimatorController.name}");
            }
            else
            {
                // –ï—Å–ª–∏ –Ω–∞ –ø—Ä–µ—Ñ–∞–±–µ —Ç–æ–∂–µ –Ω–µ—Ç - –ø—ã—Ç–∞–µ–º—Å—è –∑–∞–≥—Ä—É–∑–∏—Ç—å RogueAnimator
                RuntimeAnimatorController rogueController = Resources.Load<RuntimeAnimatorController>("Animations/Controllers/RogueAnimator");
                if (rogueController == null)
                {
                    // –ü—Ä–æ–±—É–µ–º –±–µ–∑ –ø–∞–ø–∫–∏ Animations
                    rogueController = Resources.Load<RuntimeAnimatorController>("RogueAnimator");
                }

                if (rogueController != null)
                {
                    skeletonAnimator.runtimeAnimatorController = rogueController;
                    Log($"‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω RogueAnimator –∏–∑ Resources");
                }
                else
                {
                    Log($"‚ö†Ô∏è RogueAnimator –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ Resources");
                }
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // CAPSULE COLLIDER
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        CapsuleCollider skeletonCollider = skeleton.GetComponent<CapsuleCollider>();
        if (skeletonCollider == null)
        {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ—Å—Ç—å –ª–∏ –Ω–∞ –ø—Ä–µ—Ñ–∞–±–µ
            CapsuleCollider prefabCollider = prefab.GetComponent<CapsuleCollider>();
            if (prefabCollider != null)
            {
                // –ö–æ–ø–∏—Ä—É–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Å –ø—Ä–µ—Ñ–∞–±–∞
                skeletonCollider = skeleton.AddComponent<CapsuleCollider>();
                skeletonCollider.center = prefabCollider.center;
                skeletonCollider.radius = prefabCollider.radius;
                skeletonCollider.height = prefabCollider.height;
                skeletonCollider.direction = prefabCollider.direction;
                Log($"‚úÖ CapsuleCollider —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω —Å –ø—Ä–µ—Ñ–∞–±–∞");
            }
            else
            {
                // –°–æ–∑–¥–∞—ë–º –¥–µ—Ñ–æ–ª—Ç–Ω—ã–π Capsule Collider –¥–ª—è humanoid
                skeletonCollider = skeleton.AddComponent<CapsuleCollider>();
                skeletonCollider.center = new Vector3(0, 1f, 0);
                skeletonCollider.radius = 0.3f;
                skeletonCollider.height = 2f;
                skeletonCollider.direction = 1; // Y-axis
                Log($"‚úÖ CapsuleCollider —Å–æ–∑–¥–∞–Ω (default humanoid)");
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // RIGIDBODY
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        Rigidbody skeletonRb = skeleton.GetComponent<Rigidbody>();
        if (skeletonRb == null)
        {
            Rigidbody prefabRb = prefab.GetComponent<Rigidbody>();
            if (prefabRb != null)
            {
                // –ö–æ–ø–∏—Ä—É–µ–º Rigidbody —Å –ø—Ä–µ—Ñ–∞–±–∞
                skeletonRb = skeleton.AddComponent<Rigidbody>();
                skeletonRb.mass = prefabRb.mass;
                skeletonRb.linearDamping = prefabRb.linearDamping;
                skeletonRb.angularDamping = prefabRb.angularDamping;
                skeletonRb.useGravity = prefabRb.useGravity;
                skeletonRb.isKinematic = prefabRb.isKinematic;
                skeletonRb.interpolation = prefabRb.interpolation;
                skeletonRb.collisionDetectionMode = prefabRb.collisionDetectionMode;
                skeletonRb.constraints = prefabRb.constraints;
                Log($"‚úÖ Rigidbody —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω —Å –ø—Ä–µ—Ñ–∞–±–∞");
            }
            else
            {
                // –°–æ–∑–¥–∞—ë–º –¥–µ—Ñ–æ–ª—Ç–Ω—ã–π Rigidbody –¥–ª—è —Å–∫–µ–ª–µ—Ç–∞
                skeletonRb = skeleton.AddComponent<Rigidbody>();
                skeletonRb.mass = 50f;
                skeletonRb.useGravity = true;
                skeletonRb.isKinematic = false;
                skeletonRb.constraints = RigidbodyConstraints.FreezeRotationX | RigidbodyConstraints.FreezeRotationZ;
                Log($"‚úÖ Rigidbody —Å–æ–∑–¥–∞–Ω (default skeleton)");
            }
        }

        Log($"üé≠ Skeleton –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã");
    }

    /// <summary>
    /// –¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è (Bear Form –¥–ª—è Paladin/Druid)
    /// </summary>
    private void ExecuteTransformation(SkillConfig skill)
    {
        Log($"Using transformation skill: {skill.skillName}");

        // –°–ø–∞–≤–Ω–∏–º –≤–∏–∑—É–∞–ª—å–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ (Bear Form –∏ —Ç.–¥.)
        SpawnEffect(skill.castEffectPrefab, transform.position, Quaternion.identity, 2f, "", "transformation_cast");
        SpawnEffect(skill.casterEffectPrefab, transform.position + Vector3.up * 1.5f, Quaternion.identity, 2f, "", "transformation_aura");

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ prefab —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
        if (skill.transformationModel == null)
        {
            Log($"‚ùå Transformation model –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –¥–ª—è {skill.skillName}!");
            return;
        }

        // –ü–æ–ª—É—á–∞–µ–º –∫–æ–º–ø–æ–Ω–µ–Ω—Ç SimpleTransformation
        SimpleTransformation transformation = GetComponent<SimpleTransformation>();
        if (transformation == null)
        {
            transformation = gameObject.AddComponent<SimpleTransformation>();
            Log($"‚úÖ SimpleTransformation –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –¥–æ–±–∞–≤–ª–µ–Ω");
        }

        // –ü–æ–ª—É—á–∞–µ–º –∞–Ω–∏–º–∞—Ç–æ—Ä –ø–∞–ª–∞–¥–∏–Ω–∞ –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ –≤ TransformTo
        Animator paladinAnimator = GetComponent<Animator>();
        if (paladinAnimator == null)
        {
            paladinAnimator = GetComponentInChildren<Animator>();
        }

        // –í—ã–ø–æ–ª–Ω—è–µ–º —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—é
        bool success = transformation.TransformTo(skill.transformationModel, paladinAnimator);

        if (!success)
        {
            Log($"‚ùå –¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è –Ω–µ —É–¥–∞–ª–∞—Å—å!");
            return;
        }

        Log($"‚úÖ –¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∞: {skill.skillName}");
        Log($"üêª –ú–æ–¥–µ–ª—å —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏: {skill.transformationModel.name}");

        // –ü—Ä–∏–º–µ–Ω—è–µ–º —Å—Ç–∞—Ç—É—Å-—ç—Ñ—Ñ–µ–∫—Ç—ã —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ (–µ—Å–ª–∏ –µ—Å—Ç—å)
        if (skill.effects != null && skill.effects.Count > 0)
        {
            EffectManager targetEffectManager = GetComponent<EffectManager>();
            if (targetEffectManager != null)
            {
                foreach (EffectConfig effect in skill.effects)
                {
                    targetEffectManager.ApplyEffect(effect, stats);
                    Log($"Effect applied: {effect.effectType}");
                }
            }
        }

        // –ü—Ä–∏–º–µ–Ω—è–µ–º –±–æ–Ω—É—Å—ã —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ (HP, —É—Ä–æ–Ω)
        if (skill.hpBonusPercent > 0)
        {
            HealthSystem healthSystem = GetComponent<HealthSystem>();
            if (healthSystem != null)
            {
                float hpBonus = healthSystem.MaxHealth * (skill.hpBonusPercent / 100f);
                // TODO: –î–æ–±–∞–≤–∏—Ç—å –≤—Ä–µ–º–µ–Ω–Ω—ã–π –±–æ–Ω—É—Å –∫ MaxHP
                Log($"üíö HP –±–æ–Ω—É—Å: +{skill.hpBonusPercent}% (+{hpBonus:F0} HP)");
            }
        }

        if (skill.damageBonusPercent > 0)
        {
            // TODO: –î–æ–±–∞–≤–∏—Ç—å –≤—Ä–µ–º–µ–Ω–Ω—ã–π –±–æ–Ω—É—Å –∫ —É—Ä–æ–Ω—É —á–µ—Ä–µ–∑ CharacterStats
            Log($"‚öîÔ∏è –£—Ä–æ–Ω –±–æ–Ω—É—Å: +{skill.damageBonusPercent}%");
        }

        // –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–∞–π–º–µ—Ä –≤–æ–∑–≤—Ä–∞—Ç–∞ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏
        if (skill.transformationDuration > 0)
        {
            StartCoroutine(RevertTransformationAfterDelay(transformation, skill.transformationDuration));
            Log($"‚è±Ô∏è –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏: {skill.transformationDuration} —Å–µ–∫—É–Ω–¥");
        }
    }

    /// <summary>
    /// –í–æ–∑–≤—Ä–∞—Ç –∏–∑ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ –ø–æ—Å–ª–µ –∑–∞–¥–µ—Ä–∂–∫–∏
    /// </summary>
    private IEnumerator RevertTransformationAfterDelay(SimpleTransformation transformation, float delay)
    {
        yield return new WaitForSeconds(delay);

        if (transformation != null && transformation.IsTransformed())
        {
            transformation.RevertToOriginal();
            Log($"‚è±Ô∏è –¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–∏–ª–∞—Å—å (–≤—Ä–µ–º—è –∏—Å—Ç–µ–∫–ª–æ)");

            // –°–ø–∞–≤–Ω–∏–º —ç—Ñ—Ñ–µ–∫—Ç –≤–æ–∑–≤—Ä–∞—Ç–∞ –∏–∑ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏
            GameObject revertEffect = Resources.Load<GameObject>("Effects/CFXR Magic Poof");
            if (revertEffect != null)
            {
                SpawnEffect(revertEffect, transform.position, Quaternion.identity, 1.5f, "", "transformation_revert");
            }
        }
    }

    private void Log(string message)
    {
        if (enableLogs)
        {
            Debug.Log("[SkillExecutor] " + message);
        }
    }

    public SkillConfig GetEquippedSkill(int slotIndex)
    {
        if (slotIndex < 0 || slotIndex >= equippedSkills.Count)
        {
            return null;
        }
        return equippedSkills[slotIndex];
    }

    /// <summary>
    /// –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∞–∫—Ç–∏–≤–µ–Ω –ª–∏ —ç—Ñ—Ñ–µ–∫—Ç Root/Stun (–±–ª–æ–∫–∏—Ä—É–µ—Ç –¥–≤–∏–∂–µ–Ω–∏–µ)
    /// </summary>
    public bool IsRooted()
    {
        if (effectManager == null)
        {
            effectManager = GetComponent<EffectManager>();
            if (effectManager == null) return false;
        }

        return effectManager.IsRooted();
    }

    /// <summary>
    /// –ü—Ä–∏–º–µ–Ω–∏—Ç—å —ç—Ñ—Ñ–µ–∫—Ç –Ω–∞ —Ü–µ–ª—å (–¥–ª—è projectile —Å–∫—Ä–∏–ø—Ç–æ–≤)
    /// </summary>
    public void ApplyEffectToTarget(EffectConfig effect, Transform target)
    {
        if (target == null)
        {
            Debug.LogWarning("[SkillExecutor] ‚ö†Ô∏è –¶–µ–ª—å –¥–ª—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è —ç—Ñ—Ñ–µ–∫—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞!");
            return;
        }

        EffectManager targetEffectManager = target.GetComponent<EffectManager>();
        if (targetEffectManager == null)
        {
            Debug.LogWarning($"[SkillExecutor] ‚ö†Ô∏è –£ —Ü–µ–ª–∏ {target.name} –Ω–µ—Ç EffectManager!");
            return;
        }

        targetEffectManager.AddEffect(effect, transform);
        Log($"‚ú® –≠—Ñ—Ñ–µ–∫—Ç {effect.effectType} –ø—Ä–∏–º–µ–Ω—ë–Ω –Ω–∞ {target.name}");
    }
}
