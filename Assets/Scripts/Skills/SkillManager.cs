using UnityEngine;
using System.Collections.Generic;

/// <summary>
/// –ú–µ–Ω–µ–¥–∂–µ—Ä —Å–∫–∏–ª–ª–æ–≤ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ (–∑–∞–≥—Ä—É–∂–∞–µ—Ç—Å—è –≤ Arena)
/// –£–ø—Ä–∞–≤–ª—è–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã–º–∏ —Å–∫–∏–ª–ª–∞–º–∏, –∫—É–ª–¥–∞—É–Ω–∞–º–∏ –∏ —ç—Ñ—Ñ–µ–∫—Ç–∞–º–∏
/// </summary>
public class SkillManager : MonoBehaviour
{
    [Header("–ê–∫—Ç–∏–≤–Ω—ã–µ —Å–∫–∏–ª–ª—ã (–∑–∞–≥—Ä—É–∂–∞—é—Ç—Å—è –∏–∑ Character Selection)")]
    public List<SkillData> equippedSkills = new List<SkillData>(3); // –ú–∞–∫—Å–∏–º—É–º 3 —Å–∫–∏–ª–ª–∞

    [Header("–í—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ —Å–∫–∏–ª–ª—ã –∫–ª–∞—Å—Å–∞")]
    public List<SkillData> allAvailableSkills = new List<SkillData>(6); // –î–æ 6 —Å–∫–∏–ª–ª–æ–≤ –Ω–∞ –∫–ª–∞—Å—Å

    [Header("–ö–æ–º–ø–æ–Ω–µ–Ω—Ç—ã")]
    private CharacterStats characterStats;
    private ManaSystem manaSystem;
    private HealthSystem healthSystem;
    private Animator animator;

    // –ö—É–ª–¥–∞—É–Ω—ã —Å–∫–∏–ª–ª–æ–≤ (skillId -> –æ—Å—Ç–∞–≤—à–µ–µ—Å—è –≤—Ä–µ–º—è)
    private Dictionary<int, float> skillCooldowns = new Dictionary<int, float>();

    // –ê–∫—Ç–∏–≤–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã –Ω–∞ –ø–µ—Ä—Å–æ–Ω–∞–∂–µ
    private List<ActiveEffect> activeEffects = new List<ActiveEffect>();

    // –°–æ–±—ã—Ç–∏—è
    public delegate void SkillUsedHandler(SkillData skill);
    public event SkillUsedHandler OnSkillUsed;

    public delegate void EffectAppliedHandler(SkillEffect effect);
    public event EffectAppliedHandler OnEffectApplied;

    // –ü—Ä–∏–∑–≤–∞–Ω–Ω—ã–µ —Å—É—â–µ—Å—Ç–≤–∞ (–¥–ª—è Rogue)
    private List<GameObject> summonedCreatures = new List<GameObject>();

    // –¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è (–¥–ª—è Paladin) - SIMPLE TRANSFORMATION APPROACH
    public bool isTransformed = false; // PUBLIC –¥–ª—è NetworkSyncManager
    private float transformationHPBonus = 0f; // –°–æ—Ö—Ä–∞–Ω—è–µ–º –±–æ–Ω—É—Å HP –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è

    void Start()
    {
        characterStats = GetComponent<CharacterStats>();
        manaSystem = GetComponent<ManaSystem>();
        healthSystem = GetComponent<HealthSystem>();
        animator = GetComponent<Animator>();

        Debug.Log($"[SkillManager] –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω. –≠–∫–∏–ø–∏—Ä–æ–≤–∞–Ω–æ —Å–∫–∏–ª–ª–æ–≤: {equippedSkills.Count}");
    }

    void Update()
    {
        // –û–±–Ω–æ–≤–ª—è–µ–º –∫—É–ª–¥–∞—É–Ω—ã
        UpdateCooldowns();

        // –û–±–Ω–æ–≤–ª—è–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã
        UpdateActiveEffects();
    }

    /// <summary>
    /// –ó–∞–≥—Ä—É–∑–∏—Ç—å —Å–∫–∏–ª–ª—ã –∏–∑ Character Selection (–≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞)
    /// </summary>
    public void LoadEquippedSkills(List<int> skillIds)
    {
        equippedSkills.Clear();

        foreach (int skillId in skillIds)
        {
            SkillData skill = GetSkillById(skillId);
            if (skill != null)
            {
                equippedSkills.Add(skill);
                Debug.Log($"[SkillManager] –ó–∞–≥—Ä—É–∂–µ–Ω —Å–∫–∏–ª–ª: {skill.skillName}");
            }
        }

        Debug.Log($"[SkillManager] ‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω–æ {equippedSkills.Count} —Å–∫–∏–ª–ª–æ–≤");
    }

    /// <summary>
    /// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–∫–∏–ª–ª –ø–æ –∏–Ω–¥–µ–∫—Å—É (0-2)
    /// </summary>
    public bool UseSkill(int skillIndex, Transform target = null)
    {
        if (skillIndex < 0 || skillIndex >= equippedSkills.Count)
        {
            Debug.LogWarning($"[SkillManager] –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∏–Ω–¥–µ–∫—Å —Å–∫–∏–ª–ª–∞: {skillIndex}");
            return false;
        }

        SkillData skill = equippedSkills[skillIndex];
        return UseSkill(skill, target);
    }

    /// <summary>
    /// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–∫–∏–ª–ª
    /// </summary>
    public bool UseSkill(SkillData skill, Transform target = null)
    {
        if (skill == null)
        {
            Debug.LogError("[SkillManager] ‚ùå Skill is NULL!");
            return false;
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω—Ç—Ä–æ–ª—è (—Å—Ç–∞–Ω, –º–æ–ª—á–∞–Ω–∏–µ –∏ —Ç.–¥.)
        if (IsUnderCrowdControl())
        {
            Debug.Log("[SkillManager] ‚ùå –ù–µ –º–æ–≥—É –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–∫–∏–ª–ª - –ø–µ—Ä—Å–æ–Ω–∞–∂ –ø–æ–¥ –∫–æ–Ω—Ç—Ä–æ–ª–µ–º!");
            return false;
        }

        // –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï: –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ –î–û —Ç—Ä–∞—Ç—ã –º–∞–Ω—ã
        if (skill.skillType == SkillType.Transformation && isTransformed)
        {
            Debug.Log("[SkillManager] ‚ùå –£–∂–µ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω! –ù–µ–ª—å–∑—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–∫–∏–ª–ª —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏.");
            return false;
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
        float currentCooldown = GetCooldown(skill.skillId);

        if (!skill.CanUse(characterStats, manaSystem, currentCooldown))
        {
            if (manaSystem != null)
            {
                Debug.Log($"[SkillManager] üîç –¢–µ–∫—É—â–∞—è –º–∞–Ω–∞: {manaSystem.CurrentMana}/{manaSystem.MaxMana}, –¢—Ä–µ–±—É–µ—Ç—Å—è: {skill.manaCost}");
            }
            Debug.Log($"[SkillManager] ‚ùå –°–∫–∏–ª–ª {skill.skillName} –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω (–∫—É–ª–¥–∞—É–Ω: {currentCooldown:F1}—Å)");
            return false;
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ü–µ–ª–∏
        if (skill.requiresTarget && target == null)
        {
            Debug.Log($"[SkillManager] ‚ùå –°–∫–∏–ª–ª {skill.skillName} —Ç—Ä–µ–±—É–µ—Ç —Ü–µ–ª—å!");
            return false;
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–ª—å–Ω–æ—Å—Ç–∏
        if (target != null && Vector3.Distance(transform.position, target.position) > skill.castRange)
        {
            Debug.Log($"[SkillManager] ‚ùå –¶–µ–ª—å —Å–ª–∏—à–∫–æ–º –¥–∞–ª–µ–∫–æ! ({Vector3.Distance(transform.position, target.position):F1}–º > {skill.castRange}–º)");
            return false;
        }

        // –¢—Ä–∞—Ç–∏–º –º–∞–Ω—É
        if (manaSystem != null)
        {
            manaSystem.SpendMana(skill.manaCost);
        }

        // –ó–∞–ø—É—Å–∫–∞–µ–º –∫—É–ª–¥–∞—É–Ω
        skillCooldowns[skill.skillId] = skill.cooldown;

        // –ü—Ä–æ–∏–≥—Ä—ã–≤–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é —Å –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏ –∏–∑ SkillData
        PlaySkillAnimation(skill);

        // –ù–û–í–û–ï: –í—ã–ø–æ–ª–Ω—è–µ–º –¥–≤–∏–∂–µ–Ω–∏–µ –µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–æ
        if (skill.enableMovement)
        {
            PerformSkillMovement(skill, target);
        }

        // –ë–ª–æ–∫–∏—Ä—É–µ–º –¥–≤–∏–∂–µ–Ω–∏–µ –µ—Å–ª–∏ —Ç—Ä–µ–±—É–µ—Ç—Å—è
        if (skill.blockMovementDuringCast)
        {
            BlockMovement(skill);
        }

        // –ü—Ä–æ–∏–≥—Ä—ã–≤–∞–µ–º –∑–≤—É–∫ –∫–∞—Å—Ç–∞
        if (skill.castSound != null)
        {
            AudioSource.PlayClipAtPoint(skill.castSound, transform.position);
        }

        // –ù–û–í–û–ï: –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–∫–∏–ª–ª –Ω–∞ —Å–µ—Ä–≤–µ—Ä –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –≤ –º—É–ª—å—Ç–∏–ø–ª–µ–µ—Ä–µ
        SendSkillToServer(skill, target);

        // –í—ã–ø–æ–ª–Ω—è–µ–º —Å–∫–∏–ª–ª –ª–æ–∫–∞–ª—å–Ω–æ (—Å –∑–∞–¥–µ—Ä–∂–∫–æ–π castTime –µ—Å–ª–∏ –µ—Å—Ç—å)
        if (skill.castTime > 0f)
        {
            StartCoroutine(ExecuteSkillAfterCastTime(skill, target));
        }
        else
        {
            ExecuteSkill(skill, target);
        }

        // –°–æ–±—ã—Ç–∏–µ
        OnSkillUsed?.Invoke(skill);

        Debug.Log($"[SkillManager] ‚ö° –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω —Å–∫–∏–ª–ª: {skill.skillName}");
        return true;
    }

    /// <summary>
    /// –í—ã–ø–æ–ª–Ω–∏—Ç—å —Å–∫–∏–ª–ª
    /// </summary>
    private void ExecuteSkill(SkillData skill, Transform target)
    {
        switch (skill.skillType)
        {
            case SkillType.Damage:
                ExecuteDamageSkill(skill, target);
                break;

            case SkillType.Heal:
                ExecuteHealSkill(skill, target);
                break;

            case SkillType.Buff:
            case SkillType.Debuff:
            case SkillType.CrowdControl:
                ExecuteEffectSkill(skill, target);
                break;

            case SkillType.Summon:
                ExecuteSummonSkill(skill);
                break;

            case SkillType.Transformation:
                ExecuteTransformationSkill(skill);
                break;

            case SkillType.Ressurect:
                ExecuteRessurectSkill(skill, target);
                break;
        }
    }

    /// <summary>
    /// –°–∫–∏–ª–ª —É—Ä–æ–Ω–∞
    /// </summary>
    private void ExecuteDamageSkill(SkillData skill, Transform target)
    {
        float damage = skill.CalculateDamage(characterStats);

        // AOE —É—Ä–æ–Ω
        if (skill.aoeRadius > 0f)
        {
            Vector3 center = target != null ? target.position : transform.position;

            // –°–ü–ï–¶–ò–ê–õ–¨–ù–ê–Ø –û–ë–†–ê–ë–û–¢–ö–ê –î–õ–Ø ICE NOVA (skillId 202) - —Å–æ–∑–¥–∞—ë–º —Ä–∞–¥–∏–∞–ª—å–Ω—ã–µ —Å–Ω–∞—Ä—è–¥—ã
            if (skill.skillId == 202 && skill.projectilePrefab != null)
            {
                SpawnIceNovaShards(skill, center, damage);
            }
            // –û–±—ã—á–Ω—ã–π –≤–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç –¥–ª—è –¥—Ä—É–≥–∏—Ö AOE —Å–∫–∏–ª–æ–≤
            else if (skill.visualEffectPrefab != null)
            {
                GameObject effectObj = Instantiate(skill.visualEffectPrefab, center, Quaternion.identity);
                Debug.Log($"[SkillManager] ‚ú® AOE –≤–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç —Å–æ–∑–¥–∞–Ω –≤ —Ü–µ–Ω—Ç—Ä–µ: {skill.visualEffectPrefab.name}");

                // –°–ò–ù–•–†–û–ù–ò–ó–ê–¶–ò–Ø: –û—Ç–ø—Ä–∞–≤–ª—è–µ–º AOE –≤–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç –Ω–∞ —Å–µ—Ä–≤–µ—Ä
                if (SocketIOManager.Instance != null && SocketIOManager.Instance.IsConnected)
                {
                    string effectName = skill.visualEffectPrefab.name;
                    SocketIOManager.Instance.SendVisualEffect(
                        "aoe", // —Ç–∏–ø —ç—Ñ—Ñ–µ–∫—Ç–∞
                        effectName, // –Ω–∞–∑–≤–∞–Ω–∏–µ prefab
                        center, // –ø–æ–∑–∏—Ü–∏—è —Ü–µ–Ω—Ç—Ä–∞ AOE
                        Quaternion.identity, // —Ä–æ—Ç–∞—Ü–∏—è
                        "", // –Ω–µ –ø—Ä–∏–≤—è–∑–∞–Ω –∫ –∏–≥—Ä–æ–∫—É
                        0f // –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
                    );
                    Debug.Log($"[SkillManager] ‚ú® AOE —ç—Ñ—Ñ–µ–∫—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ —Å–µ—Ä–≤–µ—Ä: {effectName}");
                }
            }

            Collider[] hits = Physics.OverlapSphere(center, skill.aoeRadius);

            int hitCount = 0;
            foreach (Collider hit in hits)
            {
                if (hitCount >= skill.maxTargets) break;

                Enemy enemy = hit.GetComponent<Enemy>();
                if (enemy != null)
                {
                    enemy.TakeDamage(damage);

                    // –í–ê–ñ–ù–û: –ü—Ä–∏–º–µ–Ω—è–µ–º –≤—Å–µ —ç—Ñ—Ñ–µ–∫—Ç—ã –∏–∑ SkillData –∫ –≤—Ä–∞–≥—É!
                    if (skill.effects != null && skill.effects.Count > 0)
                    {
                        foreach (SkillEffect effect in skill.effects)
                        {
                            ApplyEffect(effect, enemy.transform);
                        }
                        Debug.Log($"[SkillManager] ‚úÖ –ü—Ä–∏–º–µ–Ω–µ–Ω–æ {skill.effects.Count} —ç—Ñ—Ñ–µ–∫—Ç–æ–≤ –∫ {enemy.GetEnemyName()}");
                    }

                    // –í–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç –ø–æ–ø–∞–¥–∞–Ω–∏—è –Ω–∞ –≤—Ä–∞–≥–µ
                    if (skill.projectileHitEffectPrefab != null)
                    {
                        Instantiate(skill.projectileHitEffectPrefab, enemy.transform.position, Quaternion.identity);
                    }

                    hitCount++;
                }
            }

            Debug.Log($"[SkillManager] üí• AOE —É—Ä–æ–Ω: {damage} –ø–æ {hitCount} —Ü–µ–ª—è–º");
        }
        // –û–¥–∏–Ω–æ—á–Ω—ã–π —É—Ä–æ–Ω
        else if (target != null)
        {
            // –í–ê–ñ–ù–û: –ï—Å–ª–∏ –µ—Å—Ç—å —Å–Ω–∞—Ä—è–¥ - –ù–ï –Ω–∞–Ω–æ—Å–∏–º —É—Ä–æ–Ω –Ω–∞–ø—Ä—è–º—É—é! –°–Ω–∞—Ä—è–¥ –Ω–∞–Ω–µ—Å—ë—Ç —É—Ä–æ–Ω –ø—Ä–∏ –ø–æ–ø–∞–¥–∞–Ω–∏–∏
            if (skill.projectilePrefab != null)
            {
                Debug.Log($"[SkillManager] üîç –ü—Ä–µ—Ñ–∞–± —Å–Ω–∞—Ä—è–¥–∞ –Ω–∞–π–¥–µ–Ω –¥–ª—è {skill.skillName}: {skill.projectilePrefab.name}");

                // –°–æ–∑–¥–∞—ë–º —Å–Ω–∞—Ä—è–¥ (—Ç–æ–ª—å–∫–æ –¥–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞)
                NetworkPlayer networkPlayer = GetComponent<NetworkPlayer>();
                if (networkPlayer == null)
                {
                    Debug.Log($"[SkillManager] ‚úÖ –õ–æ–∫–∞–ª—å–Ω—ã–π –∏–≥—Ä–æ–∫ - —Å–æ–∑–¥–∞—ë–º —Å–Ω–∞—Ä—è–¥");
                    SpawnProjectile(skill, target, damage);
                }
                else
                {
                    Debug.Log($"[SkillManager] ‚è≠Ô∏è NetworkPlayer - –ø—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–æ–∑–¥–∞–Ω–∏–µ —Å–Ω–∞—Ä—è–¥–∞");
                }
            }
            // –ù–µ—Ç —Å–Ω–∞—Ä—è–¥–∞ - —É—Ä–æ–Ω –Ω–∞–ø—Ä—è–º—É—é (–º–≥–Ω–æ–≤–µ–Ω–Ω—ã–π)
            else
            {
                Enemy enemy = target.GetComponent<Enemy>();
                if (enemy != null)
                {
                    enemy.TakeDamage(damage);

                    // –í–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç
                    if (skill.visualEffectPrefab != null)
                    {
                        GameObject effectObj = Instantiate(skill.visualEffectPrefab, target.position, Quaternion.identity);

                        // –°–ò–ù–•–†–û–ù–ò–ó–ê–¶–ò–Ø: –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç –Ω–∞ —Å–µ—Ä–≤–µ—Ä
                        if (SocketIOManager.Instance != null && SocketIOManager.Instance.IsConnected)
                        {
                            string effectName = skill.visualEffectPrefab.name;
                            SocketIOManager.Instance.SendVisualEffect(
                                "skill_hit", // —Ç–∏–ø —ç—Ñ—Ñ–µ–∫—Ç–∞
                                effectName, // –Ω–∞–∑–≤–∞–Ω–∏–µ prefab
                                target.position, // –ø–æ–∑–∏—Ü–∏—è
                                Quaternion.identity, // —Ä–æ—Ç–∞—Ü–∏—è
                                "", // –Ω–µ –ø—Ä–∏–≤—è–∑–∞–Ω –∫ –∏–≥—Ä–æ–∫—É
                                0f // –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
                            );
                            Debug.Log($"[SkillManager] ‚ú® –í–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç —Å–∫–∏–ª–ª–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ —Å–µ—Ä–≤–µ—Ä: {effectName}");
                        }
                    }

                    Debug.Log($"[SkillManager] üí• –£—Ä–æ–Ω (–º–≥–Ω–æ–≤–µ–Ω–Ω—ã–π): {damage}");
                }
            }
        }
    }

    /// <summary>
    /// –°–∫–∏–ª–ª –ª–µ—á–µ–Ω–∏—è
    /// </summary>
    private void ExecuteHealSkill(SkillData skill, Transform target)
    {
        float healAmount = skill.CalculateDamage(characterStats);

        // –õ–µ—á–∏–º —Ü–µ–ª—å
        Transform healTarget = target != null ? target : transform;
        HealthSystem targetHealth = healTarget.GetComponent<HealthSystem>();

        if (targetHealth != null)
        {
            targetHealth.Heal(healAmount);

            // –í–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç
            if (skill.visualEffectPrefab != null)
            {
                GameObject effectObj = Instantiate(skill.visualEffectPrefab, healTarget.position, Quaternion.identity);

                // –°–ò–ù–•–†–û–ù–ò–ó–ê–¶–ò–Ø: –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç –Ω–∞ —Å–µ—Ä–≤–µ—Ä
                if (SocketIOManager.Instance != null && SocketIOManager.Instance.IsConnected)
                {
                    string effectName = skill.visualEffectPrefab.name;
                    SocketIOManager.Instance.SendVisualEffect(
                        "heal", // —Ç–∏–ø —ç—Ñ—Ñ–µ–∫—Ç–∞
                        effectName, // –Ω–∞–∑–≤–∞–Ω–∏–µ prefab
                        healTarget.position, // –ø–æ–∑–∏—Ü–∏—è
                        Quaternion.identity, // —Ä–æ—Ç–∞—Ü–∏—è
                        "", // –Ω–µ –ø—Ä–∏–≤—è–∑–∞–Ω –∫ –∏–≥—Ä–æ–∫—É (–º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ø—Ä–∏–≤—è–∑–∫—É)
                        0f // –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
                    );
                    Debug.Log($"[SkillManager] ‚ú® –í–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç –ª–µ—á–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ —Å–µ—Ä–≤–µ—Ä: {effectName}");
                }
            }

            Debug.Log($"[SkillManager] üíö –õ–µ—á–µ–Ω–∏–µ: {healAmount} HP");
        }
    }

    /// <summary>
    /// –°–∫–∏–ª–ª —Å —ç—Ñ—Ñ–µ–∫—Ç–∞–º–∏ (–±–∞—Ñ/–¥–µ–±–∞—Ñ/–∫–æ–Ω—Ç—Ä–æ–ª—å)
    /// </summary>
    private void ExecuteEffectSkill(SkillData skill, Transform target)
    {
        Transform effectTarget = target != null ? target : transform;

        // –°–ù–ê–†–Ø–î (–¥–ª—è Hammer of Justice –∏ –¥—Ä—É–≥–∏—Ö projectile-based CC —Å–∫–∏–ª–ª–æ–≤)
        if (skill.projectilePrefab != null && target != null)
        {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —ç—Ç–æ NetworkPlayer (–≤—Ä–∞–≥)?
            NetworkPlayer networkPlayer = GetComponent<NetworkPlayer>();
            if (networkPlayer == null)
            {
                // –°–æ–∑–¥–∞—ë–º —Å–Ω–∞—Ä—è–¥ —Ç–æ–ª—å–∫–æ –¥–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞
                float damage = skill.CalculateDamage(characterStats);
                SpawnProjectile(skill, target, damage);
                Debug.Log($"[SkillManager] ‚öîÔ∏è –°–Ω–∞—Ä—è–¥ —Å–æ–∑–¥–∞–Ω –¥–ª—è {skill.skillName}, —ç—Ñ—Ñ–µ–∫—Ç–æ–≤: {skill.effects.Count}");
            }
            else
            {
                Debug.Log($"[SkillManager] ‚è≠Ô∏è NetworkPlayer detected - –ø—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–Ω–∞—Ä—è–¥ –¥–ª—è {skill.skillName}");
            }

            // –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï: –ï—Å–ª–∏ –µ—Å—Ç—å —Å–Ω–∞—Ä—è–¥ - –ù–ï –ø—Ä–∏–º–µ–Ω—è–µ–º —ç—Ñ—Ñ–µ–∫—Ç—ã —Å—Ä–∞–∑—É!
            // –°–Ω–∞—Ä—è–¥ –ø—Ä–∏–º–µ–Ω–∏—Ç —ç—Ñ—Ñ–µ–∫—Ç—ã –ø—Ä–∏ –ø–æ–ø–∞–¥–∞–Ω–∏–∏ —á–µ—Ä–µ–∑ Projectile.ApplyEffects()
            Debug.Log($"[SkillManager] ‚è≠Ô∏è –≠—Ñ—Ñ–µ–∫—Ç—ã –±—É–¥—É—Ç –ø—Ä–∏–º–µ–Ω–µ–Ω—ã —Å–Ω–∞—Ä—è–¥–æ–º –ø—Ä–∏ –ø–æ–ø–∞–¥–∞–Ω–∏–∏");
        }
        // –ë–µ–∑ —Å–Ω–∞—Ä—è–¥–∞ - –ø—Ä–∏–º–µ–Ω—è–µ–º —ç—Ñ—Ñ–µ–∫—Ç—ã —Å—Ä–∞–∑—É (–±–∞—Ñ—Ñ—ã –Ω–∞ —Å–µ–±—è, –¥–µ–±–∞—Ñ—Ñ—ã –≤ –æ–±–ª–∞—Å—Ç–∏ –∏ —Ç.–¥.)
        else
        {
            // –í–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç (–¥–ª—è —Å–∫–∏–ª–ª–æ–≤ –±–µ–∑ —Å–Ω–∞—Ä—è–¥–æ–≤)
            if (skill.visualEffectPrefab != null)
            {
                Instantiate(skill.visualEffectPrefab, effectTarget.position, Quaternion.identity);
            }

            // –ü—Ä–∏–º–µ–Ω—è–µ–º –≤—Å–µ —ç—Ñ—Ñ–µ–∫—Ç—ã —Å–∫–∏–ª–ª–∞
            foreach (SkillEffect effect in skill.effects)
            {
                ApplyEffect(effect, effectTarget);
            }

            Debug.Log($"[SkillManager] ‚ú® –ü—Ä–∏–º–µ–Ω–µ–Ω–æ —ç—Ñ—Ñ–µ–∫—Ç–æ–≤: {skill.effects.Count}");
        }
    }

    /// <summary>
    /// –°–∫–∏–ª–ª –ø—Ä–∏–∑—ã–≤–∞ (Rogue - —Å–∫–µ–ª–µ—Ç—ã)
    /// </summary>
    private void ExecuteSummonSkill(SkillData skill)
    {
        if (skill.summonPrefab == null)
        {
            Debug.LogWarning("[SkillManager] –ù–µ—Ç –ø—Ä–µ—Ñ–∞–±–∞ –¥–ª—è –ø—Ä–∏–∑—ã–≤–∞!");
            return;
        }

        // –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã—Ö –ø—Ä–∏–∑–≤–∞–Ω–Ω—ã—Ö
        ClearSummons();

        // –ü—Ä–∏–∑—ã–≤–∞–µ–º —Å—É—â–µ—Å—Ç–≤
        for (int i = 0; i < skill.summonCount; i++)
        {
            Vector3 spawnPos = transform.position + transform.forward * 2f + transform.right * (i - skill.summonCount / 2) * 1.5f;
            GameObject summon = Instantiate(skill.summonPrefab, spawnPos, Quaternion.identity);

            // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –ø—Ä–∏–∑–≤–∞–Ω–Ω–æ–µ —Å—É—â–µ—Å—Ç–≤–æ
            SummonedCreature creature = summon.GetComponent<SummonedCreature>();
            if (creature == null)
            {
                creature = summon.AddComponent<SummonedCreature>();
            }
            creature.Initialize(transform, skill.summonDuration);

            summonedCreatures.Add(summon);
        }

        Debug.Log($"[SkillManager] üëª –ü—Ä–∏–∑–≤–∞–Ω–æ —Å—É—â–µ—Å—Ç–≤: {skill.summonCount}");
    }

    /// <summary>
    /// –°–∫–∏–ª–ª —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ (Paladin - –º–µ–¥–≤–µ–¥—å) - SIMPLE TRANSFORMATION
    /// –°–æ–∑–¥–∞—ë–º –º–æ–¥–µ–ª—å –º–µ–¥–≤–µ–¥—è –∫–∞–∫ child –æ–±—ä–µ–∫—Ç, —Å–∫—Ä—ã–≤–∞–µ–º –ø–∞–ª–∞–¥–∏–Ω–∞
    /// </summary>
    private void ExecuteTransformationSkill(SkillData skill)
    {
        Debug.Log($"[SkillManager] üîç ExecuteTransformationSkill (SIMPLE TRANSFORMATION) –≤—ã–∑–≤–∞–Ω –¥–ª—è {skill.skillName}");

        if (skill.transformationModel == null)
        {
            Debug.LogError("[SkillManager] ‚ùå –ù–ï–¢ –ú–û–î–ï–õ–ò –î–õ–Ø –¢–†–ê–ù–°–§–û–†–ú–ê–¶–ò–ò! –ü—Ä–æ–≤–µ—Ä—å Paladin_BearForm.asset –≤ –∏–Ω—Å–ø–µ–∫—Ç–æ—Ä–µ!");
            return;
        }

        // –í–ò–ó–£–ê–õ–¨–ù–´–ô –≠–§–§–ï–ö–¢ –¢–†–ê–ù–°–§–û–†–ú–ê–¶–ò–ò (–¥—ã–º/–º–∞–≥–∏—è)
        if (skill.visualEffectPrefab != null)
        {
            GameObject effectObj = Instantiate(skill.visualEffectPrefab, transform.position, Quaternion.identity);
            Debug.Log($"[SkillManager] ‚ú® –≠—Ñ—Ñ–µ–∫—Ç —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ –ø—Ä–æ–∏–≥—Ä–∞–Ω: {skill.visualEffectPrefab.name}");

            // –°–ò–ù–•–†–û–ù–ò–ó–ê–¶–ò–Ø: –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ –Ω–∞ —Å–µ—Ä–≤–µ—Ä
            if (SocketIOManager.Instance != null && SocketIOManager.Instance.IsConnected)
            {
                string effectName = skill.visualEffectPrefab.name;
                SocketIOManager.Instance.SendVisualEffect(
                    "transformation", // —Ç–∏–ø —ç—Ñ—Ñ–µ–∫—Ç–∞
                    effectName, // –Ω–∞–∑–≤–∞–Ω–∏–µ prefab
                    transform.position, // –ø–æ–∑–∏—Ü–∏—è
                    Quaternion.identity, // —Ä–æ—Ç–∞—Ü–∏—è
                    "", // –Ω–µ –ø—Ä–∏–≤—è–∑–∞–Ω –∫ –∏–≥—Ä–æ–∫—É (–º–æ–∂–Ω–æ –ø—Ä–∏–≤—è–∑–∞—Ç—å –µ—Å–ª–∏ –Ω—É–∂–Ω–æ)
                    0f // –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
                );
                Debug.Log($"[SkillManager] ‚ú® –≠—Ñ—Ñ–µ–∫—Ç —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ —Å–µ—Ä–≤–µ—Ä: {effectName}");
            }
        }

        // –ü–æ–ª—É—á–∞–µ–º –∏–ª–∏ –¥–æ–±–∞–≤–ª—è–µ–º SimpleTransformation –∫–æ–º–ø–æ–Ω–µ–Ω—Ç
        SimpleTransformation simpleTransformation = GetComponent<SimpleTransformation>();
        if (simpleTransformation == null)
        {
            simpleTransformation = gameObject.AddComponent<SimpleTransformation>();
            Debug.Log($"[SkillManager] ‚ûï –î–æ–±–∞–≤–ª–µ–Ω SimpleTransformation –∫–æ–º–ø–æ–Ω–µ–Ω—Ç");
        }

        // –í—ã–ø–æ–ª–Ω—è–µ–º —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—é (–ø–µ—Ä–µ–¥–∞—ë–º –∞–Ω–∏–º–∞—Ç–æ—Ä –ø–∞–ª–∞–¥–∏–Ω–∞ —è–≤–Ω–æ)
        bool success = simpleTransformation.TransformTo(skill.transformationModel, animator);
        if (!success)
        {
            Debug.LogError("[SkillManager] ‚ùå –¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è –Ω–µ —É–¥–∞–ª–∞—Å—å!");
            return;
        }

        isTransformed = true;

        Debug.Log($"[SkillManager] üêª ‚úÖ –¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞ - –ø–∞–ª–∞–¥–∏–Ω –ø—Ä–µ–≤—Ä–∞—Ç–∏–ª—Å—è –≤ –º–µ–¥–≤–µ–¥—è!");

        // –ü—Ä–∏–º–µ–Ω—è–µ–º –±–æ–Ω—É—Å—ã
        if (healthSystem != null && skill.hpBonusPercent > 0f)
        {
            transformationHPBonus = healthSystem.MaxHealth * (skill.hpBonusPercent / 100f);
            healthSystem.AddTemporaryMaxHealth(transformationHPBonus);
            Debug.Log($"[SkillManager] ‚úÖ –ë–æ–Ω—É—Å HP: +{transformationHPBonus:F0} ({skill.hpBonusPercent}%)");
        }

        // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ—Ç–∫–ª—é—á–∞–µ–º —á–µ—Ä–µ–∑ –≤—Ä–µ–º—è
        Invoke(nameof(EndTransformation), skill.transformationDuration);

        Debug.Log($"[SkillManager] üêª ‚úÖ –¢–†–ê–ù–°–§–û–†–ú–ê–¶–ò–Ø –ê–ö–¢–ò–í–ò–†–û–í–ê–ù–ê (SIMPLE TRANSFORMATION) –Ω–∞ {skill.transformationDuration}—Å!");
    }

    /// <summary>
    /// –ó–∞–≤–µ—Ä—à–∏—Ç—å —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—é - SIMPLE TRANSFORMATION
    /// </summary>
    private void EndTransformation()
    {
        if (!isTransformed) return;

        // –ü–æ–ª—É—á–∞–µ–º SimpleTransformation –∫–æ–º–ø–æ–Ω–µ–Ω—Ç
        SimpleTransformation simpleTransformation = GetComponent<SimpleTransformation>();
        if (simpleTransformation != null)
        {
            // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–∞–ª–∞–¥–∏–Ω–∞ (—É–¥–∞–ª—è–µ–º –º–µ–¥–≤–µ–¥—è, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–∞–ª–∞–¥–∏–Ω–∞)
            simpleTransformation.RevertToOriginal();
            Debug.Log($"[SkillManager] ‚úÖ –ü–∞–ª–∞–¥–∏–Ω –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω");
        }

        // –£–±–∏—Ä–∞–µ–º –±–æ–Ω—É—Å HP
        if (healthSystem != null && transformationHPBonus > 0f)
        {
            healthSystem.RemoveTemporaryMaxHealth(transformationHPBonus);
            transformationHPBonus = 0f;
        }

        isTransformed = false;

        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞ —Å–µ—Ä–≤–µ—Ä –æ–∫–æ–Ω—á–∞–Ω–∏–µ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏
        if (SocketIOManager.Instance != null && SocketIOManager.Instance.IsConnected)
        {
            SocketIOManager.Instance.SendTransformationEnd();
        }

        Debug.Log("[SkillManager] üêª –¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞ (SIMPLE TRANSFORMATION)");
    }

    /// <summary>
    /// –°–∫–∏–ª–ª –≤–æ—Å–∫—Ä–µ—à–µ–Ω–∏—è
    /// </summary>
    private void ExecuteRessurectSkill(SkillData skill, Transform target)
    {
        // TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –≤–æ—Å–∫—Ä–µ—à–µ–Ω–∏–µ
        Debug.Log($"[SkillManager] ‚ö∞Ô∏è –í–æ—Å–∫—Ä–µ—à–µ–Ω–∏–µ (–Ω–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ)");
    }

    /// <summary>
    /// –ü—Ä–∏–º–µ–Ω–∏—Ç—å —ç—Ñ—Ñ–µ–∫—Ç –∫ —Ü–µ–ª–∏
    /// </summary>
    private void ApplyEffect(SkillEffect effect, Transform target)
    {
        if (target == null) return;

        // –î–ª—è –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞
        Enemy enemy = target.GetComponent<Enemy>();
        if (enemy != null)
        {
            SkillManager enemySkillManager = enemy.GetComponent<SkillManager>();
            if (enemySkillManager == null)
            {
                enemySkillManager = enemy.gameObject.AddComponent<SkillManager>();
            }
            enemySkillManager.AddEffect(effect, target);
        }
        // –î–ª—è —Å–µ–±—è/—Å–æ—é–∑–Ω–∏–∫–∞
        else
        {
            AddEffect(effect, target);
        }

        OnEffectApplied?.Invoke(effect);
    }

    /// <summary>
    /// –î–æ–±–∞–≤–∏—Ç—å —ç—Ñ—Ñ–µ–∫—Ç
    /// </summary>
    public void AddEffect(SkillEffect effect, Transform target)
    {
        ActiveEffect activeEffect = new ActiveEffect(effect, target);
        activeEffects.Add(activeEffect);

        Debug.Log($"[SkillManager] ‚ú® –î–æ–±–∞–≤–ª–µ–Ω —ç—Ñ—Ñ–µ–∫—Ç: {effect.effectType} –Ω–∞ {effect.duration}—Å");
    }

    /// <summary>
    /// –û–±–Ω–æ–≤–∏—Ç—å –∫—É–ª–¥–∞—É–Ω—ã (–ò–°–ü–†–ê–í–õ–ï–ù–û: –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–ø–∏—Å–æ–∫ –∫–ª—é—á–µ–π)
    /// </summary>
    private void UpdateCooldowns()
    {
        if (skillCooldowns.Count == 0) return;

        var keys = new List<int>(skillCooldowns.Keys);

        foreach (int skillId in keys)
        {
            float cooldown = skillCooldowns[skillId];

            if (cooldown > 0f)
            {
                skillCooldowns[skillId] = Mathf.Max(0f, cooldown - Time.deltaTime);
            }
        }
    }

    /// <summary>
    /// –û–±–Ω–æ–≤–∏—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã
    /// </summary>
    private void UpdateActiveEffects()
    {
        for (int i = activeEffects.Count - 1; i >= 0; i--)
        {
            bool shouldRemove = activeEffects[i].Update(Time.deltaTime);
            if (shouldRemove)
            {
                activeEffects.RemoveAt(i);
            }
        }
    }

    /// <summary>
    /// –ü–æ–ª—É—á–∏—Ç—å –∫—É–ª–¥–∞—É–Ω —Å–∫–∏–ª–ª–∞
    /// </summary>
    public float GetCooldown(int skillId)
    {
        return skillCooldowns.ContainsKey(skillId) ? skillCooldowns[skillId] : 0f;
    }

    /// <summary>
    /// –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω—Ç—Ä–æ–ª—è
    /// </summary>
    public bool IsUnderCrowdControl()
    {
        foreach (ActiveEffect effect in activeEffects)
        {
            if (effect.isStunned || effect.isSilenced)
            {
                return true;
            }
        }
        return false;
    }

    /// <summary>
    /// –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–±–µ–∑–¥–≤–∏–∂–∏–≤–∞–Ω–∏—è
    /// </summary>
    public bool IsRooted()
    {
        foreach (ActiveEffect effect in activeEffects)
        {
            if (effect.isRooted || effect.isStunned)
            {
                return true;
            }
        }
        return false;
    }

    /// <summary>
    /// –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–µ—É—è–∑–≤–∏–º–æ—Å—Ç–∏
    /// </summary>
    public bool IsInvulnerable()
    {
        foreach (ActiveEffect effect in activeEffects)
        {
            if (effect.isInvulnerable)
            {
                return true;
            }
        }
        return false;
    }

    /// <summary>
    /// –ù–∞–π—Ç–∏ —Å–∫–∏–ª–ª –ø–æ ID
    /// </summary>
    private SkillData GetSkillById(int skillId)
    {
        foreach (SkillData skill in allAvailableSkills)
        {
            if (skill.skillId == skillId)
            {
                return skill;
            }
        }
        return null;
    }

    /// <summary>
    /// –û—á–∏—Å—Ç–∏—Ç—å –ø—Ä–∏–∑–≤–∞–Ω–Ω—ã—Ö —Å—É—â–µ—Å—Ç–≤
    /// </summary>
    private void ClearSummons()
    {
        foreach (GameObject summon in summonedCreatures)
        {
            if (summon != null)
            {
                Destroy(summon);
            }
        }
        summonedCreatures.Clear();
    }

    /// <summary>
    /// –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–∫–∏–ª–ª –Ω–∞ —Å–µ—Ä–≤–µ—Ä –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏
    /// –û–ë–ù–û–í–õ–ï–ù–û: –¢–µ–ø–µ—Ä—å –ø–µ—Ä–µ–¥–∞–µ—Ç skillType, –∞–Ω–∏–º–∞—Ü–∏—é –∏ –≤–∏–∑—É–∞–ª—å–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã
    /// </summary>
    private void SendSkillToServer(SkillData skill, Transform target)
    {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –º—ã –≤ –º—É–ª—å—Ç–∏–ø–ª–µ–µ—Ä–µ
        if (SocketIOManager.Instance == null || !SocketIOManager.Instance.IsConnected)
        {
            Debug.Log("[SkillManager] –ù–µ –≤ –º—É–ª—å—Ç–∏–ø–ª–µ–µ—Ä–µ - –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –æ—Ç–ø—Ä–∞–≤–∫—É –Ω–∞ —Å–µ—Ä–≤–µ—Ä");
            return;
        }

        // –ü–æ–ª—É—á–∞–µ–º target socketId (–µ—Å–ª–∏ —Ü–µ–ª—å - –¥—Ä—É–≥–æ–π –∏–≥—Ä–æ–∫)
        string targetSocketId = "";
        if (target != null)
        {
            NetworkPlayer networkTarget = target.GetComponent<NetworkPlayer>();
            if (networkTarget != null)
            {
                targetSocketId = networkTarget.socketId;
            }
        }

        // –í–ê–ñ–ù–û: –ü–µ—Ä–µ–¥–∞–µ–º —Ç–∏–ø —Å–∫–∏–ª–ª–∞ –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ
        string skillType = skill.skillType.ToString(); // "Transformation", "Damage", "Heal" –∏ —Ç.–¥.

        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞ —Å–µ—Ä–≤–µ—Ä —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ–± –∞–Ω–∏–º–∞—Ü–∏–∏
        Vector3 targetPos = target != null ? target.position : transform.position;
        SocketIOManager.Instance.SendPlayerSkillWithAnimation(
            skill.skillId,
            targetSocketId,
            targetPos,
            skillType,
            skill.animationTrigger,
            skill.animationSpeed,
            skill.castTime
        );

        Debug.Log($"[SkillManager] üì° –°–∫–∏–ª–ª {skill.skillName} (ID:{skill.skillId}, —Ç–∏–ø:{skillType}, –∞–Ω–∏–º–∞—Ü–∏—è:{skill.animationTrigger}, castTime:{skill.castTime}—Å) –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ —Å–µ—Ä–≤–µ—Ä");
    }

    /// <summary>
    /// –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–∑–¥–∞–Ω–∏–µ —Å–Ω–∞—Ä—è–¥–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏
    /// </summary>
    private void SendProjectileToServer(int skillId, Vector3 spawnPosition, Vector3 direction, Transform target)
    {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –º—ã –≤ –º—É–ª—å—Ç–∏–ø–ª–µ–µ—Ä–µ
        if (SocketIOManager.Instance == null || !SocketIOManager.Instance.IsConnected)
        {
            Debug.Log("[SkillManager] –ù–µ –≤ –º—É–ª—å—Ç–∏–ø–ª–µ–µ—Ä–µ - –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –æ—Ç–ø—Ä–∞–≤–∫—É —Å–Ω–∞—Ä—è–¥–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä");
            return;
        }

        // –ü–æ–ª—É—á–∞–µ–º target socketId (–µ—Å–ª–∏ —Ü–µ–ª—å - –¥—Ä—É–≥–æ–π –∏–≥—Ä–æ–∫)
        string targetSocketId = "";
        if (target != null)
        {
            NetworkPlayer networkTarget = target.GetComponent<NetworkPlayer>();
            if (networkTarget != null)
            {
                targetSocketId = networkTarget.socketId;
            }
        }

        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞ —Å–µ—Ä–≤–µ—Ä
        SocketIOManager.Instance.SendProjectileSpawned(skillId, spawnPosition, direction, targetSocketId);

        Debug.Log($"[SkillManager] üöÄ –°–Ω–∞—Ä—è–¥ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ —Å–µ—Ä–≤–µ—Ä: skillId={skillId}, pos={spawnPosition}, dir={direction}");
    }

    /// <summary>
    /// –°–æ–∑–¥–∞—Ç—å –ª–µ–¥—è–Ω—ã–µ –æ—Å–∫–æ–ª–∫–∏ –¥–ª—è Ice Nova (—Ä–∞–¥–∏–∞–ª—å–Ω–æ –≤–æ –≤—Å–µ —Å—Ç–æ—Ä–æ–Ω—ã)
    /// –í–ê–ñ–ù–û: –¢–æ–ª—å–∫–æ –¥–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –∏–≥—Ä–æ–∫–∞! –ù–µ –¥–ª—è NetworkPlayer!
    /// </summary>
    private void SpawnIceNovaShards(SkillData skill, Vector3 center, float damage)
    {
        // –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï: –ü—Ä–æ–≤–µ—Ä—è–µ–º —ç—Ç–æ NetworkPlayer (–≤—Ä–∞–≥)?
        NetworkPlayer networkPlayer = GetComponent<NetworkPlayer>();
        if (networkPlayer != null)
        {
            Debug.Log($"[SkillManager] ‚è≠Ô∏è NetworkPlayer detected - –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –≤–∏–∑—É–∞–ª—å–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã Ice Nova");
            return;
        }

        int shardCount = 12;
        float spawnHeight = 1f;
        float angleStep = 360f / shardCount;

        Vector3 spawnPosition = center + Vector3.up * spawnHeight;

        for (int i = 0; i < shardCount; i++)
        {
            // –í—ã—á–∏—Å–ª—è–µ–º —É–≥–æ–ª –¥–ª—è —ç—Ç–æ–≥–æ –æ—Å–∫–æ–ª–∫–∞
            float angle = i * angleStep;

            // –î–æ–±–∞–≤–ª—è–µ–º —Å–ª—É—á–∞–π–Ω–æ—Å—Ç—å
            angle += Random.Range(-angleStep * 0.2f, angleStep * 0.2f);

            // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
            Vector3 direction = Quaternion.Euler(0, angle, 0) * Vector3.forward;

            // –°–æ–∑–¥–∞–µ–º –æ—Å–∫–æ–ª–æ–∫
            GameObject shard = Instantiate(skill.projectilePrefab, spawnPosition, Quaternion.LookRotation(direction));

            // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º Projectile
            Projectile projectile = shard.GetComponent<Projectile>();
            if (projectile != null)
            {
                projectile.Initialize(null, damage, direction, gameObject, skill.effects);
            }

            // –°–ò–ù–•–†–û–ù–ò–ó–ê–¶–ò–Ø: –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–∞–∂–¥—ã–π –æ—Å–∫–æ–ª–æ–∫ –Ω–∞ —Å–µ—Ä–≤–µ—Ä –¥–ª—è –º—É–ª—å—Ç–∏–ø–ª–µ–µ—Ä–∞
            if (SocketIOManager.Instance != null && SocketIOManager.Instance.IsConnected)
            {
                SocketIOManager.Instance.SendProjectileSpawned(
                    skill.skillId, // 202 –¥–ª—è Ice Nova
                    spawnPosition,
                    direction,
                    "" // targetSocketId - –æ—Å–∫–æ–ª–∫–∏ –Ω–µ –Ω–∞–≤–æ–¥—è—Ç—Å—è
                );
                Debug.Log($"[SkillManager] üì° Ice Nova shard {i + 1} sent to server: angle={angle:F1}¬∞, dir={direction}");
            }
        }

        Debug.Log($"[SkillManager] ‚ùÑÔ∏è Ice Nova: Spawned {shardCount} ice shards!");
    }

    /// <summary>
    /// –°–æ–∑–¥–∞—Ç—å —Å–Ω–∞—Ä—è–¥ (–ù–û–í–û–ï - centralized method)
    /// </summary>
    private void SpawnProjectile(SkillData skill, Transform target, float damage)
    {
        // DEBUG: –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –ø—Ä–µ—Ñ–∞–± –∑–∞–≥—Ä—É–∂–µ–Ω
        if (skill.projectilePrefab == null)
        {
            Debug.LogError($"[SkillManager] ‚ùå projectilePrefab == NULL –¥–ª—è —Å–∫–∏–ª–ª–∞ {skill.skillName}!");
            return;
        }

        Debug.Log($"[SkillManager] üì¶ –°–æ–∑–¥–∞—ë–º —Å–Ω–∞—Ä—è–¥ –∏–∑ –ø—Ä–µ—Ñ–∞–±–∞: {skill.projectilePrefab.name}");

        GameObject projectile = Instantiate(skill.projectilePrefab, transform.position + Vector3.up, Quaternion.identity);

        Debug.Log($"[SkillManager] ‚úÖ –°–Ω–∞—Ä—è–¥ —Å–æ–∑–¥–∞–Ω –≤ —Å—Ü–µ–Ω–µ: {projectile.name}");

        Projectile proj = projectile.GetComponent<Projectile>();

        if (proj != null)
        {
            Vector3 direction = (target.position - transform.position).normalized;
            Vector3 spawnPosition = transform.position + Vector3.up;

            // –ù–û–í–û–ï: –ò—Å–ø–æ–ª—å–∑—É–µ–º InitializeFromSkill –¥–ª—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –≤—Å–µ—Ö –Ω–∞—Å—Ç—Ä–æ–µ–∫ –∏–∑ SkillData
            proj.InitializeFromSkill(skill, target, direction, gameObject);

            Debug.Log($"[SkillManager] üöÄ –°–Ω–∞—Ä—è–¥ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω: {skill.projectilePrefab.name}, —É—Ä–æ–Ω: {damage}, —Å–∫–æ—Ä–æ—Å—Ç—å: {skill.projectileSpeed}, homing: {skill.projectileHoming}");

            // –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï: –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞ —Å–µ—Ä–≤–µ—Ä –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ —Å –¥—Ä—É–≥–∏–º–∏ –∏–≥—Ä–æ–∫–∞–º–∏
            SendProjectileToServer(skill.skillId, spawnPosition, direction, target);
        }
        else
        {
            Debug.LogError($"[SkillManager] ‚ùå –£ –ø—Ä–µ—Ñ–∞–±–∞ {projectile.name} –Ω–µ—Ç –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞ Projectile!");
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // –°–ò–°–¢–ï–ú–ê –ê–ù–ò–ú–ê–¶–ò–ô –°–ö–ò–õ–õ–û–í
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    /// <summary>
    /// –ü—Ä–æ–∏–≥—Ä–∞—Ç—å –∞–Ω–∏–º–∞—Ü–∏—é —Å–∫–∏–ª–ª–∞ —Å –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏ —Å–∫–æ—Ä–æ—Å—Ç–∏
    /// –û–ë–ù–û–í–õ–ï–ù–û: –í—Å–µ–≥–¥–∞ –∏–≥—Ä–∞–µ—Ç "Attack" –∞–Ω–∏–º–∞—Ü–∏—é (–∫–∞–∫ —É –º–∞–≥–∞) –ø–µ—Ä–µ–¥ –ª—é–±—ã–º —Å–∫–∏–ª–ª–æ–º!
    /// </summary>
    private void PlaySkillAnimation(SkillData skill)
    {
        if (animator == null)
        {
            Debug.LogWarning("[SkillManager] ‚ö†Ô∏è Animator –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç!");
            return;
        }

        // –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –ò–ó–ú–ï–ù–ï–ù–ò–ï: –í—Å–µ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º "Attack" –∫–∞–∫ –∞–Ω–∏–º–∞—Ü–∏—é –∫–∞—Å—Ç–∞!
        // –≠—Ç–æ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –∞–Ω–∏–º–∞—Ü–∏—è –∫–∞—Å—Ç–∞ –º–∞–≥–∏–∏/—Å–∫–∏–ª–ª–∞ –¥–ª—è –í–°–ï–• –∫–ª–∞—Å—Å–æ–≤
        string castAnimationTrigger = "Attack";

        // –ï—Å–ª–∏ —É —Å–∫–∏–ª–ª–∞ –∑–∞–¥–∞–Ω —Å–≤–æ–π —Ç—Ä–∏–≥–≥–µ—Ä - –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ, –∏–Ω–∞—á–µ "Attack"
        if (!string.IsNullOrEmpty(skill.animationTrigger))
        {
            castAnimationTrigger = skill.animationTrigger;
        }

        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å –∞–Ω–∏–º–∞—Ü–∏–∏
        float previousSpeed = animator.speed;
        animator.speed = skill.animationSpeed;

        // –ó–∞–ø—É—Å–∫–∞–µ–º —Ç—Ä–∏–≥–≥–µ—Ä –∞–Ω–∏–º–∞—Ü–∏–∏ –∫–∞—Å—Ç–∞
        animator.SetTrigger(castAnimationTrigger);

        Debug.Log($"[SkillManager] üé¨ –ê–Ω–∏–º–∞—Ü–∏—è –ö–ê–°–¢–ê: —Ç—Ä–∏–≥–≥–µ—Ä='{castAnimationTrigger}', —Å–∫–æ—Ä–æ—Å—Ç—å={skill.animationSpeed}x");

        // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å –∞–Ω–∏–º–∞—Ü–∏–∏ —á–µ—Ä–µ–∑ castTime –∏–ª–∏ –Ω–µ–±–æ–ª—å—à—É—é –∑–∞–¥–µ—Ä–∂–∫—É
        float resetDelay = skill.castTime > 0f ? skill.castTime : 1f;
        StartCoroutine(ResetAnimationSpeed(previousSpeed, resetDelay));
    }

    /// <summary>
    /// –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–∫–æ—Ä–æ—Å—Ç—å –∞–Ω–∏–º–∞—Ü–∏–∏ –ø–æ—Å–ª–µ –∫–∞—Å—Ç–∞
    /// </summary>
    private System.Collections.IEnumerator ResetAnimationSpeed(float originalSpeed, float delay)
    {
        yield return new WaitForSeconds(delay);

        if (animator != null)
        {
            animator.speed = originalSpeed;
            Debug.Log($"[SkillManager] ‚è±Ô∏è –°–∫–æ—Ä–æ—Å—Ç—å –∞–Ω–∏–º–∞—Ü–∏–∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞: {originalSpeed}x");
        }
    }

    /// <summary>
    /// –í—ã–ø–æ–ª–Ω–∏—Ç—å —Å–∫–∏–ª–ª –ø–æ—Å–ª–µ –≤—Ä–µ–º–µ–Ω–∏ –∫–∞—Å—Ç–∞
    /// </summary>
    private System.Collections.IEnumerator ExecuteSkillAfterCastTime(SkillData skill, Transform target)
    {
        Debug.Log($"[SkillManager] ‚è≥ –ö–∞—Å—Ç —Å–∫–∏–ª–ª–∞ {skill.skillName}... –ñ–¥—ë–º {skill.castTime}—Å");

        yield return new WaitForSeconds(skill.castTime);

        Debug.Log($"[SkillManager] ‚úÖ –ö–∞—Å—Ç –∑–∞–≤–µ—Ä—à—ë–Ω! –í—ã–ø–æ–ª–Ω—è–µ–º —Å–∫–∏–ª–ª {skill.skillName}");
        ExecuteSkill(skill, target);
    }

    /// <summary>
    /// –ë–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –¥–≤–∏–∂–µ–Ω–∏–µ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ –≤–æ –≤—Ä–µ–º—è –∫–∞—Å—Ç–∞
    /// </summary>
    private void BlockMovement(SkillData skill)
    {
        CharacterController controller = GetComponent<CharacterController>();
        if (controller != null)
        {
            StartCoroutine(BlockMovementCoroutine(controller, skill.movementBlockDuration > 0f ? skill.movementBlockDuration : skill.castTime));
        }
    }

    /// <summary>
    /// –ö–æ—Ä—É—Ç–∏–Ω–∞ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –¥–≤–∏–∂–µ–Ω–∏—è
    /// </summary>
    private System.Collections.IEnumerator BlockMovementCoroutine(CharacterController controller, float duration)
    {
        // –ï—Å–ª–∏ duration == 0, –∏—Å–ø–æ–ª—å–∑—É–µ–º castTime –∏–ª–∏ –¥–µ—Ñ–æ–ª—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
        if (duration <= 0f)
        {
            duration = 0.5f; // –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞
        }

        Debug.Log($"[SkillManager] üîí –î–≤–∏–∂–µ–Ω–∏–µ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ –Ω–∞ {duration}—Å");

        // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–∞
        bool wasEnabled = controller.enabled;

        // –û—Ç–∫–ª—é—á–∞–µ–º –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä
        controller.enabled = false;

        // –ñ–¥—ë–º
        yield return new WaitForSeconds(duration);

        // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        controller.enabled = wasEnabled;

        Debug.Log($"[SkillManager] üîì –î–≤–∏–∂–µ–Ω–∏–µ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ");
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // –°–ò–°–¢–ï–ú–ê –î–í–ò–ñ–ï–ù–ò–Ø –°–ö–ò–õ–õ–û–í
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    /// <summary>
    /// –í—ã–ø–æ–ª–Ω–∏—Ç—å –¥–≤–∏–∂–µ–Ω–∏–µ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ –ø—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ —Å–∫–∏–ª–ª–∞
    /// </summary>
    private void PerformSkillMovement(SkillData skill, Transform target)
    {
        if (!skill.enableMovement || skill.movementType == MovementType.None)
        {
            return;
        }

        // –ü—Ä–æ–∏–≥—Ä—ã–≤–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é –¥–≤–∏–∂–µ–Ω–∏—è –µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω–∞
        if (!string.IsNullOrEmpty(skill.movementAnimationTrigger) && animator != null)
        {
            animator.SetTrigger(skill.movementAnimationTrigger);
            Debug.Log($"[SkillManager] üèÉ –ê–Ω–∏–º–∞—Ü–∏—è –¥–≤–∏–∂–µ–Ω–∏—è: {skill.movementAnimationTrigger}");
        }

        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ü–µ–ª–µ–≤—É—é –ø–æ–∑–∏—Ü–∏—é
        Vector3 targetPosition = CalculateMovementTarget(skill, target);

        // –í—ã–ø–æ–ª–Ω—è–µ–º –¥–≤–∏–∂–µ–Ω–∏–µ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞
        switch (skill.movementType)
        {
            case MovementType.Teleport:
            case MovementType.Blink:
                // –ú–≥–Ω–æ–≤–µ–Ω–Ω–∞—è —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞—Ü–∏—è
                TeleportToPosition(targetPosition);
                break;

            case MovementType.Dash:
            case MovementType.Charge:
            case MovementType.Roll:
            case MovementType.Leap:
                // –ü–ª–∞–≤–Ω–æ–µ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ
                StartCoroutine(MoveToPosition(targetPosition, skill.movementSpeed));
                break;
        }
    }

    /// <summary>
    /// –í—ã—á–∏—Å–ª–∏—Ç—å —Ü–µ–ª–µ–≤—É—é –ø–æ–∑–∏—Ü–∏—é –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è
    /// </summary>
    private Vector3 CalculateMovementTarget(SkillData skill, Transform target)
    {
        Vector3 direction = Vector3.zero;

        switch (skill.movementDirection)
        {
            case MovementDirection.Forward:
                direction = transform.forward;
                break;

            case MovementDirection.Backward:
                direction = -transform.forward;
                break;

            case MovementDirection.ToTarget:
                if (target != null)
                {
                    direction = (target.position - transform.position).normalized;
                }
                else
                {
                    direction = transform.forward;
                }
                break;

            case MovementDirection.AwayFromTarget:
                if (target != null)
                {
                    direction = (transform.position - target.position).normalized;
                }
                else
                {
                    direction = -transform.forward;
                }
                break;

            case MovementDirection.MouseDirection:
                direction = transform.forward;
                break;
        }

        return transform.position + direction * skill.movementDistance;
    }

    /// <summary>
    /// –ú–≥–Ω–æ–≤–µ–Ω–Ω–∞—è —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞—Ü–∏—è
    /// </summary>
    private void TeleportToPosition(Vector3 targetPosition)
    {
        CharacterController controller = GetComponent<CharacterController>();

        if (controller != null)
        {
            controller.enabled = false;
            transform.position = targetPosition;
            controller.enabled = true;

            Debug.Log($"[SkillManager] ‚ú® –¢–µ–ª–µ–ø–æ—Ä—Ç –≤ –ø–æ–∑–∏—Ü–∏—é: {targetPosition}");
        }
        else
        {
            transform.position = targetPosition;
        }
    }

    /// <summary>
    /// –ü–ª–∞–≤–Ω–æ–µ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –∫ –ø–æ–∑–∏—Ü–∏–∏
    /// </summary>
    private System.Collections.IEnumerator MoveToPosition(Vector3 targetPosition, float speed)
    {
        CharacterController controller = GetComponent<CharacterController>();
        Vector3 startPosition = transform.position;
        float distance = Vector3.Distance(startPosition, targetPosition);
        float duration = distance / speed;
        float elapsed = 0f;

        Debug.Log($"[SkillManager] üèÉ –ù–∞—á–∏–Ω–∞–µ–º –¥–≤–∏–∂–µ–Ω–∏–µ, —Å–∫–æ—Ä–æ—Å—Ç—å: {speed}–º/—Å, –¥–∏—Å—Ç–∞–Ω—Ü–∏—è: {distance:F1}–º");

        while (elapsed < duration)
        {
            elapsed += Time.deltaTime;
            float t = Mathf.Clamp01(elapsed / duration);

            Vector3 newPosition = Vector3.Lerp(startPosition, targetPosition, t);

            if (controller != null && controller.enabled)
            {
                Vector3 movement = newPosition - transform.position;
                controller.Move(movement);
            }
            else
            {
                transform.position = newPosition;
            }

            yield return null;
        }

        if (controller != null && controller.enabled)
        {
            Vector3 finalMovement = targetPosition - transform.position;
            controller.Move(finalMovement);
        }
        else
        {
            transform.position = targetPosition;
        }

        Debug.Log($"[SkillManager] ‚úÖ –î–≤–∏–∂–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ");
    }

    void OnDestroy()
    {
        // –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï: –û—Ç–º–µ–Ω—è–µ–º –≤—Å–µ Invoke (EndTransformation –∏ –¥—Ä—É–≥–∏–µ)
        CancelInvoke();

        ClearSummons();
    }
}
